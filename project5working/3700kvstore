#!/usr/bin/env python

import sys
import socket
import select
import time
import json
import random
from collections import deque


class ReplicaState:
    def __init__(self, index):
        self.index = index
        self.term = 0
        self.votes = 1
        self.pPending = 0
        self.pCommitted = 0
        self.status = "ok"

    def nextTerm(self):
        self.term += 1
        self.votes = 1

    def toTerm(self, term):
        if term > self.term:
            self.term = term
            self.votes = 1


class GetRequest:
    def __init__(self, msg, term):
        self.source = str(msg[u'src'])
        self.acked_nodes = []
        self.num_acked_nodes = 1
        self.quorum = False
        self.key = str(msg[u'key'])
        self.value = ""
        self.messageId = str(msg[u'MID'])
        self.term = term

    def quorumMet(self, quorum):
        if quorum > self.num_acked_nodes:
            self.quorum = False
        else:
            self.quorum = True
        return self.quorum

    def ack(self, replica_id):
        if replica_id not in self.acked_nodes:
            self.acked_nodes.append(replica_id)
            self.num_acked_nodes += 1

    def setValue(self, val):
        self.value = val

    def getEntry(self):
        return {"MID": self.messageId, "key": self.key, "value": ""}


class PutRequest:
    def __init__(self, msg, term):
        self.source = str(msg[u'src'])
        self.acked_nodes = []
        self.num_acked_nodes = 1
        self.quorum = False
        self.key = str(msg[u'key'])
        self.value = str(msg[u'value'])
        self.messageId = str(msg[u'MID'])
        self.term = term

    def quorumMet(self, quorum):
        if quorum > self.num_acked_nodes:
            self.quorum = False
        else:
            self.quorum = True
        return self.quorum

    def ack(self, replica_id):
        if replica_id not in self.acked_nodes:
            self.acked_nodes.append(replica_id)
            self.num_acked_nodes += 1

    def getLogEntry(self):
        return {'key': self.key, 'value': {'value': self.value, 'term': self.term}}


class RaftNode:
    def __init__(self, my_id, other_node_ids):
        self.my_id = my_id
        self.my_state = ReplicaState("myState")
        self.my_socket = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
        self.my_socket.connect(self.my_id)
        self.raft_size = len(other_node_ids) + 1
        self.quorum = (self.raft_size / 2) + 1
        self.other_node_ids = []
        self.other_node_states_dict = dict()
        self.other_node_states = []
        for i in range(len(other_node_ids)):
            node_id = other_node_ids[i]
            self.other_node_ids.append(other_node_ids[i])
            state = ReplicaState(i)
            self.other_node_states.append(state)
            node_state = {node_id: i}
            self.other_node_states_dict.update(node_state)
        self.getRequests = deque()
        self.putRequests = deque()
        self.pendingRequests = deque()
        self.requestLog = deque()
        self.dictionary = dict()
        self.node_type = "follower"
        self.vote_tally = 0
        self.appendResponses = 0
        self.currentLeader = "FFFF"
        self.electionTimeout = 0.3
        self.resetElectionTimeout()
        self.sendMessages = []

    ##############################
    ##                          ##
    ##     ELECTION HANDLING    ##
    ##                          ##
    ##############################

    def resetElectionTimeout(self):
        self.electionTimeout = float(float(random.randrange(500,700))/1000)
        if self.node_type == 'leader':
            print str(self.electionTimeout)


    def requestVotes(self):
        for replica_id in self.other_node_ids:
            vote = {'src': self.my_id, 'dst': replica_id, 'type': 'voteRequest', 'leader': self.currentLeader,
                    'term': self.my_state.term,
                    'candidate': self.my_id}
            self.sendMessage(vote)
        self.my_state.votes = 0

    def castVote(self, candidate, dst):
        if self.my_state.votes > 0:
            vote = {'src': self.my_id, 'dst': dst, 'type': 'vote', 'leader': self.currentLeader, 'term': self.my_state.term,
                               'candidate': candidate}
            self.sendMessage(vote)
            self.my_state.votes = 0

    def selfElect(self):
        #self.resetElectionTimeout()
        self.node_type = "candidate"
        self.my_state.nextTerm()
        # votes received
        self.vote_tally = 1
        self.requestVotes()

    def handleVote(self, msg):
        term = msg['term']
        candidate = str(msg['candidate'])
        if self.node_type == "candidate":
            if term == self.my_state.term and candidate == self.my_id:
                self.vote_tally += 1
                if self.vote_tally >= self.quorum:
                    self.becomeLeader()

    def handleVoteRequest(self, msg):
        term = msg['term']
        candidate = str(msg['candidate'])
        if term > self.my_state.term:
            self.node_type = "follower"
            self.my_state.toTerm(term)
            self.castVote(candidate, candidate)
        elif term == self.my_state.term and self.my_state.votes > 0:
            self.castVote(candidate, candidate)

    def becomeLeader(self):
        print("New leader: " + str(self.my_id) + ", Quorum: " + str(self.quorum))
        self.node_type = "leader"
        self.vote_tally = 0
        self.currentLeader = self.my_id

    ##############################
    ##                          ##
    ##     GET/PUT REQUESTS     ##
    ##                          ##
    ##############################

    def handleGet(self, msg):
        if msg[u'key']:
            if self.node_type == "leader":
                request = GetRequest(msg, self.my_state.term)
                if msg[u'key'] in self.dictionary.keys():
                    request.setValue(self.dictionary.get(msg[u'key']))

                # if there is only one node in the raft
                if request.quorumMet(self.quorum):
                    self.confirmMessage(request, "get")
                else:
                    self.getRequests.append(request)
            else:
                self.failMessage(msg)
        else:
            self.failMessage(msg)

    def confirmMessage(self, request, reqType):
        response = {}
        uni = True
        if reqType == 'get':
            if uni:
                response = {u'src': unicode(self.my_id), u'dst': unicode(request.src),
                            u'leader': unicode(self.currentLeader), u'type': u'ok',
                            u'MID': unicode(msg[u'MID']), u'value': unicode(request.value)}
            else:
                response = {'src': str(self.my_id), 'dst': str(request.src),
                            'leader': str(self.currentLeader), 'type': 'ok',
                            'MID': str(msg[u'MID']), 'value': str(request.value)}
        elif reqType == 'put':
            if uni:
                response = {u'src': unicode(self.my_id), u'dst': unicode(request.src),
                            u'leader': unicode(self.currentLeader), u'type': u'ok',
                            u'MID': unicode(msg[u'MID'])}
            else:
                response = {'src': str(self.my_id), 'dst': str(request.src),
                            'leader': str(self.currentLeader), 'type': 'ok',
                            'MID': str(msg['MID'])}
        if len(response) > 0:
            self.sendMessage(response)

    def handlePut(self, msg):
        # todo: check fail/ok conditions
        if msg[u'key'] and msg[u'value']:
            if self.node_type == "leader":
                request = PutRequest(msg, self.my_state.term)
                entry = request.getLogEntry()
                self.requestLog.append(entry)
                self.my_state.pPending += 1

                # if there is only one node in the raft
                if request.quorumMet(self.quorum):
                    self.confirmMessage(request, "put")
                    self.my_state.pCommitted += 1
                else:
                    self.putRequests.append(request)

            else:
                self.failMessage(msg)
        else:
            self.failMessage(msg)

    def failMessage(self, msg):
        # todo: might have to change else case
        response = {}
        uni = True
        # fail message
        if self.node_type == "leader":
            if uni:
                response = {u'src': unicode(self.my_id), u'dst': unicode(msg[u'src']), u'leader': unicode(self.currentLeader), u'type': u'ok',
                            u'MID': unicode(msg[u'MID'])}
            else:
                response = {'src': str(self.my_id), 'dst': str(msg['src']),
                        'leader': str(self.currentLeader), 'type': 'redirect',
                        'MID': str(msg['MID'])}
        # redirect message
        elif msg[u'dst'] == self.my_id:
            if uni:
                response = {u'src': unicode(self.my_id), u'dst': unicode(msg[u'src']),
                        u'leader': unicode(self.currentLeader), u'type': u'redirect',
                        u'MID': unicode(msg[u'MID'])}
            else:
                response = {'src': str(self.my_id), 'dst': str(msg['src']),
                        'leader': str(self.currentLeader), 'type': 'redirect',
                        'MID': str(msg['MID'])}
        if len(response) > 0:
            self.sendMessage(response)

    def validMessage(self, msg):
        return msg['src'] and msg['dst'] and msg['type'] and msg['leader']

    def writePut(key, value):
        return False

    def sendMessage(self, message):
        printMessage = True
        if printMessage:
            print str(message) + " TIME: " + str(time.time())
        self.my_socket.send(json.dumps(message))

    ########################
    ##                    ##
    ##     HEARTBEATS     ##
    ##                    ##
    ########################

    def handleHeartbeat(self, msg):
        if msg['get']:
            messageId = msg['get']['MID']
            if self.node_type == "follower":
                key = msg['get']['key']
                if key in self.dictionary.keys:
                    val = {}
                    if self.dictionary.get(key):
                        val = {}
                    getResponse = {'MID': messageId, 'key': key, 'value': {}}
                else:
                    getResponse = {'MID': messageId, 'key': key, 'value': ''}
            elif self.node_type == "leader":
                val = msg['get']['value']
                for req in self.getRequests:
                    if req.messageId == messageId and req.val == val:
                        req.ack(msg['src'])
                        if req.quorumMet(self.quorum):
                            self.confirmMessage(req, 'get')
                            self.getRequests.remove(req)
                        break

        if msg['term'] and msg['appendEntries']:
            getResponse = None
            message = {}
            if msg['term'] > self.my_state.term:
                self.my_state.toTerm(msg['term'])
                self.node_type = "follower"
                self.currentLeader = str(msg['leader'])
                message = {'src': self.my_id, 'dst': msg['src'], 'leader': self.currentLeader,
                           'term': self.my_state.term, 'type': 'heartbeat',
                           'appendEntries': {'status': 'fail', 'pPending': self.my_state.pPending,
                                             'pCommitted': self.my_state.pCommitted, "entries": {}}}
                self.sendMessage(message)
                self.failAllRequests()
            elif msg['term'] == self.my_state.term:
                if self.node_type == "leader":
                    pPend = msg['appendEntries']['pPending']
                    pComm = msg['appendEntries']['pCommitted']
                    node_state = self.other_node_states[self.other_node_states_dict.get(msg['src'])]
                    node_state.pPending = pPend
                    node_state.pCommitted = pComm
                    if msg['appendEntries']['status'] == "ok":
                        node_state.status = "ok"
                        if pPend == self.my_state.pPending and pComm == self.my_state.pCommitted:
                            if pPend - pComm > 0:
                                for i in range(pPend - pComm):
                                    self.dictionary.update(self.requestLog[i + pComm]['key'], self.requestLog[i + pComm]['value'])
                                self.my_state.pCommitted = pPend
                    elif msg['appendEntries']['status'] == "fail":
                        node_state.status = "fail"
                    if msg['appendEntries']['get']:
                        messageId = msg['appendEntries']['get']['MID']
                        for req in self.getRequests:
                            if req.messageId == messageId and req.val == val:
                                req.ack(msg['src'])
                                if req.quorumMet(self.quorum):
                                    self.confirmMessage(req, 'get')
                                    self.getRequests.remove(req)
                                    break
                elif self.node_type == "follower":
                    self.currentLeader = str(msg['leader'])
                    dest = str(msg['dst'])
                    pPend = msg['appendEntries']['pPending']
                    pComm = msg['appendEntries']['pCommitted']
                    msgEntries = msg['appendEntries']['pCommitted']
                    if msg['appendEntries']['status'] == "ok":
                        if self.my_state.pCommitted == pComm and self.my_state.pPending < pPend:
                            for i in range(pPend - self.my_state.pPending):
                                self.requestLog.append(msgEntries[i])
                            self.my_state.pPending = pPend
                            message = {'src': self.my_id, 'dst': dest, 'leader': self.currentLeader,
                                       'term': self.my_state.term, 'type': 'heartbeat',
                                       'appendEntries': {'status': 'ok', 'pPending': self.my_state.pPending,
                                                         'pCommitted': self.my_state.pCommitted, "entries": {}}, 'get': {}}
                        elif self.my_state.pPending == pPend and self.my_state.pCommitted < pComm:
                            for i in range(pComm - self.my_state.pCommitted):
                                self.dictionary.update(self.requestLog[i + self.my_state.pCommitted]['key'],
                                                       self.requestLog[i + self.my_state.pCommitted]['value'])
                            self.my_state.pCommitted = pComm
                            message = {'src': self.my_id, 'dst': dest, 'leader': self.currentLeader,
                                       'term': self.my_state.term, 'type': 'heartbeat',
                                       'appendEntries': {'status': 'ok', 'pPending': self.my_state.pPending,
                                                         'pCommitted': self.my_state.pCommitted, "entries": {}}, 'get': {}}
                        elif self.my_state.pCommitted == pComm and self.my_state.pPending == pPend:
                            message = {'src': self.my_id, 'dst': dest, 'leader': self.currentLeader,
                                       'term': self.my_state.term, 'type': 'heartbeat',
                                       'appendEntries': {'status': 'ok', 'pPending': self.my_state.pPending,
                                                         'pCommitted': self.my_state.pCommitted, "entries": {}},
                                       'get': {}}
                        else:
                            message = {'src': self.my_id, 'dst': dest, 'leader': self.currentLeader,
                                       'term': self.my_state.term, 'type': 'heartbeat',
                                       'appendEntries': {'status': 'fail', 'pPending': self.my_state.pPending,
                                                         'pCommitted': self.my_state.pCommitted, "entries": {}}, 'get': {}}
                    elif msg['appendEntries']['status'] == "override":
                        entrySubArray = self.requestLog[:pComm]
                        for i in range(pPend - self.my_state.pCommitted):
                            entrySubArray.append(msgEntries[i])
                        self.requestLog = entrySubArray
                        for i in range(pComm - self.my_state.pCommitted):
                            self.dictionary.update(self.requestLog[i + self.my_state.pCommitted]['key'],
                                                   self.requestLog[i + self.my_state.pCommitted]['value'])
                        self.my_state.pPending = pPend
                        self.my_state.pCommitted = pComm
                        message = {'src': self.my_id, 'dst': dest, 'leader': self.currentLeader,
                                   'term': self.my_state.term, 'type': 'heartbeat',
                                   'appendEntries': {'status': 'ok', 'pPending': self.my_state.pPending,
                                                     'pCommitted': self.my_state.pCommitted, "entries": {}}, 'get': {}}
                    if len(msg['get']) > 0:
                        messageId = msg['get']['MID']
                        key = msg['get']['key']
                        if key in self.dictionary.keys:
                            getResponse = {'MID': messageId, 'key': key, 'value': self.dictionary.get(key)}
                        else:
                            getResponse = {'MID': messageId, 'key': key, 'value': ''}
                        message.update("get", getResponse)
                    self.sendMessage(message)

    def heartbeat(self):
        pPend = self.my_state.pPending
        pComm = self.my_state.pCommitted
        entries = []
        getRequest = None
        if len(self.getRequests) > 0:
            getRequest = self.getRequests[0]
        message = {}
        for id in self.other_node_ids:
            node_state = self.other_node_states[self.other_node_states_dict.get(id)]
            node_pPend = node_state.pPending
            node_pComm = node_state.pCommitted
            if node_state.status == "ok":
                if pComm != pPend:
                    entries = self.requestLog[node_pComm:pPend]
                if getRequest is not None:
                    message = {"src": self.my_id, "dst": id, "leader": self.currentLeader, "type": "heartbeat",
                               "term": self.my_state.term,
                               "appendEntries": {
                                   "status": "ok", "pPending": pPend, "pCommitted": pComm, "entries": entries},
                               "get": getRequest.getEntry()}
                else:
                    message = {"src": self.my_id, "dst": id, "leader": self.currentLeader, "type": "heartbeat",
                               "term": self.my_state.term,
                               "appendEntries": {
                                   "status": "ok", "pPending": pPend, "pCommitted": pComm, "entries": entries}, 'get': {}}
            elif node_state.status == "fail":
                entries = self.requestLog[node_pComm:pPend]
                if getRequest is not None:
                    message = {"src": self.my_id, "dst": id, "leader": self.currentLeader, "type": "heartbeat",
                               "term": self.my_state.term,
                               "appendEntries": {"status": "override", "pPending": pPend, "pCommitted": pComm,
                                                 "entries": entries}, "get": getRequest.getEntry()}
                else:
                    message = {"src": self.my_id, "dst": id, "leader": self.currentLeader, "type": "heartbeat",
                               "term": self.my_state.term,
                               "appendEntries": {"status": "override", "pPending": pPend, "pCommitted": pComm,
                                                 "entries": entries}, 'get': {}}

            self.sendMessage(message)


this_node = RaftNode(sys.argv[1], sys.argv[2:])

print("Num Nodes: " + str(len(sys.argv[2:])))
print("Quorum: " + str(this_node.quorum))

# Connect to the network. All messages to/from other replicas and clients will
# occur over this socket

timer = time.time()
deltaTime = 0

# timeouts
electionTimeout = 0.15
heartbeatTimeout = 0.25


def validMessage(msg):
    return msg['src'] and msg['dst'] and msg['type'] and msg['leader']


while True:
    # logic for checking for election timeouts
    currentTime = time.time()
    deltaTime = currentTime - timer

    ready = select.select([this_node.my_socket], [], [], this_node.electionTimeout)[0]

    if this_node.my_socket in ready:
        msg_raw = this_node.my_socket.recv(32768)

        if len(msg_raw) > 0:
            this_node.resetElectionTimeout()
            msg = json.loads(msg_raw)
            if validMessage(msg):
                src = str(msg[u'src'])
                if src not in this_node.other_node_ids:
                    # For now, ignore get() and put() from clients
                    print "********************************"
                    print str(msg)
                    print "********************************"
                    type = str(msg[u'type'])
                    if type == 'get':
                        this_node.handleGet(msg)
                    elif type == 'put':
                        this_node.handlePut(msg)

                # Handle election voting
                else:
                    if str(msg['type']) == 'vote':
                        this_node.handleVote(msg)
                    elif str(msg['type']) == 'voteRequest':
                        this_node.handleVoteRequest(msg)
                    elif str(msg['type']) == 'heartbeat':
                        this_node.handleHeartbeat(msg)
            else:
                this_node.failMessage(msg)

    else:
        this_node.selfElect()

    if deltaTime >= heartbeatTimeout and this_node.node_type == "leader":
        timer = currentTime
        this_node.heartbeat()


    """
    clock = time.time()
    if clock - last > 2:
        # Send a no-op message to a random peer every two seconds, just for fun
        # You definitely want to remove this from your implementation
        msg = {'src': my_id, 'dst': random.choice(replica_ids), 'leader': 'FFFF', 'type': 'noop'}
        sock.send(json.dumps(msg))
        print('%s sending a NOOP to %s' % (msg['src'], msg['dst']))
        last = clock
    """

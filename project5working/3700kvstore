#!/usr/bin/env python3

import sys
import socket
import select
import time
import json
import random
from enum import Enum

# Your ID number
my_id = sys.argv[1]

# The ID numbers of all the other replicas
replica_ids = sys.argv[2:]

# number of replicas
replica_count = len(replica_ids) + 1

# majority
quorum = (replica_count / 2) + 1

# dictionary
dictionary = dict()

# uncommitted changes
uncommitted = dict()


# is the node a leader (all nodes start as follower
class State(Enum):
    follower = 0
    candidate = 1
    leader = 2

state = State.follower.value

# what term are we in
currentTerm = 0

# how many votes you can cast (1 per election)
votes = 1

# how many votes have you received
tally = 0

# how many replicas have committed
commits = 0

# who is the leader
currentLeader = ""

# Connect to the network. All messages to/from other replicas and clients will
# occur over this socket
sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
sock.connect(my_id)

last = 0

# timeouts
electionTimeout = 0.15
heartbeatTimeout = 0.05

def resetElectionTimeout():
    electionTimeout = float((random.randrange(150, 300)) / 1000)

resetElectionTimeout()


def handleGet(msg):
    global leader
    response = {}
    value = ""
    if state == 2:
        if msg['src'] and msg['dest'] and msg['type'] and msg['leader'] and msg['key']:
            if msg['key'] in dictionary.keys():
                value = dictionary.get(msg['key'])
                return {"src": msg['dest'], "dst": msg['src'], "leader": leader, "type": "ok", "MID": msg['MID'],
                        "value": value}
            else:
                return {"src": msg['dest'], "dst": msg['src'], "leader": leader, "type": "ok", "MID": msg['MID'],
                        "value": value}
        else:
            return {"src": msg['dest'], "dst": msg['src'], "leader": leader, "type": "fail",
                    "MID": msg['MID']}
    else:
        return {"src": msg['dest'], "dst": msg['src'], "leader": leader, "type": "redirect", "MID": msg['MID']}


def handlePut(msg):
    global leader
    value = ""
    if state == 2:
        #todo: check fail/ok conditions
        if msg['src'] and msg['dest'] and msg['type'] and msg['leader'] and msg['key'] and msg['value']:
            uncommitted.update({msg['key'], msg['value']})
            return {"src": msg['dest'], "dst": msg['src'], "leader": leader, "type": "ok", "MID": msg['MID'],
                    "value": value}
        else:
            return {"src": msg['dest'], "dst": msg['src'], "leader": leader, "type": "fail",
                    "MID": msg['MID']}
    else:
        return {"src": msg['dest'], "dst": msg['src'], "leader": leader, "type": "redirect", "MID": msg['MID']}


def writePut(key, value):
    return False


def handleVote(msg):
    global votes
    global my_id
    global state
    global term
    global tally
    if msg['src'] and msg['dest'] and msg['type'] and msg['term'] and msg['candidate']:
        if state == state.candidate.value and msg['term'] == term:
            if msg['candidate'] == my_id:
                tally+=1
                if tally == quorum:
                    inauguration()
        elif state == state.follower.value:
            if votes > 0:
                return {'src': my_id, 'dest': msg['candidate'], 'type': 'vote', 'term': term, 'candidate': msg['candidate']}


def inauguration():
    return True


def handleHeartbeat(msg):
    global currentTerm
    global currentLeader
    global state
    global dictionary
    global uncommitted
    if msg['src'] and msg['dest'] and msg['type'] and msg['term'] and msg['state'] and msg['appendEntries']:
        if msg['term'] > currentTerm:
            updateTerm(currentTerm, msg['src'])
        elif state == State.follower.value:
            if msg['term'] == currentTerm and msg['src'] == currentLeader:
                resetElectionTimeout()
            if msg['state'] == 'ready' and len(msg['appendEntries']):
                uncommitted = msg['appendEntries']
            elif msg['state'] == 'commit':
                dictionary.update(uncommitted)
        elif state == State.leader.value:



def updateTerm(term, leader):
    global currentTerm
    global currentLeader
    currentTerm = term
    currentLeader = leader


while True:
    ready = select.select([sock], [], [], heartbeatTimeout)[0]

    if sock in ready:
        msg_raw = sock.recv(32768)

        if len(msg_raw) == 0: continue
        msg = json.loads(msg_raw)

        # For now, ignore get() and put() from clients
        if msg['type'] == 'get':
            response = handleGet(msg)
            sock.send(json.dumps(response))

        elif msg['type'] == 'put':
            response = handlePut(msg)
            sock.send(response)

        # Handle election voting
        elif msg['type'] == 'vote':
            response = handleVote(msg)

        elif msg['type'] == 'heartbeat':
            print('%s received a NOOP from %s' % (msg['dst'], msg['src']))

        if state == state.leader.value:
            for id in replica_ids:
                msg = {'src': my_id, 'dest': id, 'type': 'heartbeat', 'term': term}

    clock = time.time()
    if clock - last > 2:
        # Send a no-op message to a random peer every two seconds, just for fun
        # You definitely want to remove this from your implementation
        msg = {'src': my_id, 'dst': random.choice(replica_ids), 'leader': 'FFFF', 'type': 'noop'}
        sock.send(json.dumps(msg))
        print('%s sending a NOOP to %s' % (msg['src'], msg['dst']))
        last = clock

#!/usr/bin/env python

import sys
import socket
import select
import time
import json
import random
from collections import deque


######################################################################
#   CLASS: REPLICASTATE
#
#       ARGUMENTS
#
#           index           - the index of the replica state(to be used by the ReplicaNode that stores it in an array)
#
#       ADDITIONAL STORED VARIABLES
#
#           term            - what term the ReplicaNode thinks it is in
#           votes           - the number of votes the ReplicaNode can still cast this term
#           pPending        - pointer to the where the next pending appendEntry should be placed in the log
#           pCommitted      - pointer to the next pending entry in the log to be committed
#           status          - status message to send in heartbeat responses - "ok" if synced with leader, "fail" if not
#
#       METHODS
#
#           nextTerm        - increment the term by 1 and set votes to 1
#           parsePageHTML   - increment to the given term and set votes to 1
#
class ReplicaState:
    def __init__(self, index):
        self.index = index
        self.term = 0
        self.votes = 1
        self.pPending = 0
        self.pCommitted = 0
        self.status = "ok"

    def nextTerm(self):
        self.term += 1
        self.votes = 1

    def toTerm(self, term):
        if term > self.term:
            self.term = term
            self.votes = 1


######################################################################
#   CLASS: GETREQUEST
#
#       ARGUMENTS
#
#           msg             - JSON message from which to create the GetRequest
#           term            - term in which the GetRequest was received
#           quorum          - the number of responses that constitutes a quorum
#
#       ADDITIONAL STORED VARIABLES
#
#           source          - the source of the request
#           acked_nodes     - array of the IDs of ReplicaNodes that have acked the request
#           num_acked_nodes - the number of ReplicaNodes that have acked the request
#           quorumMet       - whether or not the number of ReplicaNodes that acked the request constitutes a quorum
#           key             - dictionary key
#           value           - value of dictionary[key] to be returned to the client
#           messageId       - message Id of the client's request
#           term            - which term the request was made in
#           confirmed       - whether or not a response has been sent to the client
#
#       METHODS
#
#           ack             - add the given replicaId to the array of ackedNodes, increment num_acked_nodes,
#                             determine if a quorum has been met
#           setValue        - set the request's value to the given value
#           getEntry        - returns an entry for the request to be passed in the heartbeat
#
class GetRequest:
    def __init__(self, msg, term, quorum):
        self.term = term
        self.quorum = quorum
        self.source = str(msg['src'])
        self.acked_nodes = []
        self.num_acked_nodes = 1
        self.quorumMet = False
        self.key = str(msg['key'])
        self.value = ""
        self.messageId = str(msg['MID'])
        self.confirmed = False

    def ack(self, replica_id):
        if replica_id not in self.acked_nodes:
            self.acked_nodes.append(replica_id)
            self.num_acked_nodes += 1
            self.quorumMet = self.num_acked_nodes >= self.quorum

    def setValue(self, value):
        self.value = value

    def getEntry(self):
        return {"MID": self.messageId, "key": self.key, "value": ""}


######################################################################
#   CLASS: PUTREQUEST
#
#       ARGUMENTS
#
#           msg             - JSON message from which to create the GetRequest
#           term            - term in which the GetRequest was received
#           quorum          - the number of responses that constitutes a quorum
#
#       ADDITIONAL STORED VARIABLES
#
#           source          - the source of the request
#           acked_nodes     - array of the IDs of ReplicaNodes that have acked the request
#           num_acked_nodes - the number of ReplicaNodes that have acked the request
#           quorumMet       - whether or not the number of ReplicaNodes that acked the request constitutes a quorum
#           key             - dictionary key
#           value           - value of dictionary[key] to be stored in the dictionary
#           messageId       - message Id of the client's request
#           term            - which term the request was made in
#           confirmed       - whether or not a response has been sent to the client
#
#       METHODS
#
#           ack             - add the given replicaId to the array of ackedNodes, increment num_acked_nodes,
#                             determine if a quorum has been met
#           setValue        - set the request's value to the given value
#           getEntry        - returns an entry for the request to be passed in the heartbeat
#
class PutRequest:
    def __init__(self, msg, term, quorum):
        self.term = term
        self.quorum = quorum
        self.source = str(msg['src'])
        self.acked_nodes = []
        self.num_acked_nodes = 1
        self.quorumMet = False
        self.key = str(msg['key'])
        self.value = str(msg['value'])
        self.messageId = str(msg['MID'])
        self.confirmed = False

    def ack(self, replica_id):
        if replica_id not in self.acked_nodes:
            self.acked_nodes.append(replica_id)
            self.num_acked_nodes += 1
            self.quorumMet = self.num_acked_nodes >= self.quorum

    def getLogEntry(self):
        return {'key': self.key, 'value': {'value': self.value, 'term': self.term}}


######################################################################
#   CLASS: RAFTNODE
#
#       ARGUMENTS
#
#           my_id                   - id of the ReplicaNode
#           other_node_ids          - array of the ids of all other nodes
#
#       ADDITIONAL STORED VARIABLES
#
#           my_state                - the state of the node
#           my_socket               - socket for messages to and from the node
#           raft_size               - number of nodes in the raft
#           quorum                  - number of nodes that constitutes a quorum
#           other_node_states_dict  - map of node ids to their index in the array of node states
#           other_node_states       - array that stores state information for each of the other nodes
#           getRequests             - array of all unresolved get requests
#           putRequests             - array of all unresolved put requests
#           requestLog              - log of all client requests
#           dictionary              - dictionary that stores all [key, value] pairs
#           node_type               - whether the node is a "follower", "candidate", or "leader
#           vote_tally              - how many votes the node has received in the current election (if any)
#           currentLeader           - id of the current leader
#           electionTimeout         - election timeout value (random value between 150-300ms)
#           messageCount            - how many messages the node has sent (for use in debugging)
#           printMessage            - whether or not the node should print messages to the console
#                                     (for use in debugging)
#           maxGetReqs              - maximum number of get requests that can be sent in a heartbeat
#
#       METHODS
#
#           resetElectionTimeout    - obtain a new election timeout value for the node (150-300ms)
#           requestVotes            - request votes from other nodes
#           castVote                - cast a vote for a given candidate
#           selfElect               - initiate a new election
#           handleVote              - logic for responding to a received vote
#           handleVoteRequest       - logic for responding to a received vote
#           becomeLeader            - upon receiving a quorum of votes, become the leader
#           handleGet               - logic for responding to a get request
#           confirmMessage          - respond to a client that their request was successfully made
#           handlePut               - logic for responding to a put request
#           failMessage             - respond to a client that their request failed or redirect them to the leader
#           validMessage            - does an incoming message contain the required fields
#           sendMessage             - JSON encode a given message and send it on the socket
#           handleHeartbeat         - logic for responding to a received heartbeat
#           failAllRequests         - fail all pending requests (used when a new leader is elected before the
#                                     requests are fulfilled)
#           heartbeat               - create and send a heartbeat message (only used by the leader)
#
class RaftNode:
    def __init__(self, my_id, other_node_ids):
        self.my_id = my_id
        self.my_state = ReplicaState("myState")
        self.my_socket = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
        self.my_socket.connect(self.my_id)
        self.raft_size = len(other_node_ids) + 1
        self.quorum = (self.raft_size / 2) + 1
        self.other_node_ids = []
        self.other_node_states_dict = dict()
        self.other_node_states = []
        for i in range(len(other_node_ids)):
            node_id = other_node_ids[i]
            self.other_node_ids.append(other_node_ids[i])
            state = ReplicaState(i)
            self.other_node_states.append(state)
            self.other_node_states_dict[node_id] = i
        self.getRequests = []
        self.putRequests = []
        self.requestLog = []
        self.dictionary = dict()
        self.node_type = "follower"
        self.vote_tally = 0
        self.currentLeader = "FFFF"
        self.electionTimeout = 0.3
        self.resetElectionTimeout()
        self.messageCount = 0
        self.printMessage = False
        self.maxGetReqs = 5

    ##############################
    ##                          ##
    ##     ELECTION HANDLING    ##
    ##                          ##
    ##############################

    def resetElectionTimeout(self):
        # set the election timeout to a random number between 0.150 and 0.300
        self.electionTimeout = float(float(random.randrange(150, 300))/1000)

    def requestVotes(self):
        for replica_id in self.other_node_ids:
            vote = {'src': self.my_id, 'dst': replica_id, 'type': 'voteRequest', 'leader': self.currentLeader,
                    'term': self.my_state.term,
                    'candidate': self.my_id}
            self.sendMessage(vote)
        self.my_state.votes = 0

    def castVote(self, candidate, dst):
        if self.my_state.votes > 0:
            vote = {'src': self.my_id, 'dst': dst, 'type': 'vote', 'leader': self.currentLeader, 'term': self.my_state.term,
                               'candidate': candidate}
            self.sendMessage(vote)
            self.my_state.votes = 0

    def selfElect(self):
        #self.resetElectionTimeout()
        self.node_type = "candidate"
        self.my_state.nextTerm()
        self.currentLeader = self.my_id
        # votes received
        self.vote_tally = 1
        # print "ELECTION{'term': " + str(self.my_state.term) + ", 'candidate': " + str(self.my_id) + ", 'time': " + str(currentTime) + "}"
        self.requestVotes()

    def handleVote(self, msg):
        term = msg['term']
        candidate = str(msg['candidate'])
        if self.node_type == "candidate":
            if term == self.my_state.term and candidate == self.my_id:
                self.vote_tally += 1
                if self.vote_tally >= self.quorum:
                    self.becomeLeader()

    def handleVoteRequest(self, msg):
        term = msg['term']
        candidate = str(msg['candidate'])
        if term > self.my_state.term:
            self.node_type = "follower"
            self.my_state.toTerm(term)
            self.currentLeader = candidate
            self.castVote(candidate, candidate)
        elif term == self.my_state.term and self.my_state.votes > 0:
            self.castVote(candidate, candidate)

    def becomeLeader(self):
        #print("New leader: " + str(self.my_id) + ", Quorum: " + str(self.quorum))
        self.node_type = "leader"
        self.vote_tally = 0
        self.currentLeader = self.my_id

    ##############################
    ##                          ##
    ##     GET/PUT REQUESTS     ##
    ##                          ##
    ##############################

    def handleGet(self, msg):
        if msg['key']:
            if self.node_type == "leader":
                request = GetRequest(msg, self.my_state.term)
                if msg['key'] in self.dictionary.keys():
                    request.setValue(self.dictionary.get(msg['key'])['value'])

                # if there is only one node in the raft
                if request.quorumMet(self.quorum):
                    self.confirmMessage(request, "get")
                else:
                    self.getRequests.append(request)
            else:
                self.failMessage(msg)
        else:
            self.failMessage(msg)

    def confirmMessage(self, request, reqType):
        response = {}
        uni = True
        if reqType == 'get':
            if uni:
                response = {'src': str(self.my_id), 'dst': str(request.source),
                            'leader': str(self.currentLeader), 'type': 'ok',
                            'MID': str(request.messageId), 'value': str(request.value)}
            else:
                response = {'src': str(self.my_id), 'dst': str(request.source),
                            'leader': str(self.currentLeader), 'type': 'ok',
                            'MID': str(request.messageId), 'value': str(request.value)}
        elif reqType == 'put':
            if uni:
                response = {'src': str(self.my_id), 'dst': str(request.source),
                            'leader': str(self.currentLeader), 'type': 'ok',
                            'MID': str(request.messageId)}
            else:
                response = {'src': str(self.my_id), 'dst': str(request.source),
                            'leader': str(self.currentLeader), 'type': 'ok',
                            'MID': str(request.messageId)}
        if len(response) > 0:
            if self.printMessage:
                print "################################"
                print str(response) + "TIME: " + str(time.time()) + " MSG# " + str(self.messageCount)
                print "################################"
            self.sendMessage(response)

    def handlePut(self, msg):
        # todo: check fail/ok conditions
        if msg['key'] and msg['value']:
            if self.node_type == "leader":
                request = PutRequest(msg, self.my_state.term)
                entry = request.getLogEntry()
                self.requestLog.append(entry)
                self.my_state.pPending += 1

                # if there is only one node in the raft
                if request.quorumMet(self.quorum):
                    self.confirmMessage(request, "put")
                    self.my_state.pCommitted += 1
                else:
                    self.putRequests.append(request)

            else:
                self.failMessage(msg)
        else:
            self.failMessage(msg)

    def failMessage(self, msg):
        # todo: might have to change else case
        response = {}
        uni = True
        # fail message
        if self.my_id == self.currentLeader:
            if uni:
                response = {'src': str(self.my_id), 'dst': str(msg['src']), 'leader': str(self.currentLeader), 'type': 'fail',
                            'MID': str(msg['MID'])}
            else:
                response = {'src': str(self.my_id), 'dst': str(msg['src']),
                        'leader': str(self.currentLeader), 'type': 'fail',
                        'MID': str(msg['MID'])}
        # redirect message
        elif msg['dst'] == self.my_id:
            if uni:
                response = {'src': str(self.my_id), 'dst': str(msg['src']),
                        'leader': str(self.currentLeader), 'type': 'redirect',
                        'MID': str(msg['MID'])}
            else:
                response = {'src': str(self.my_id), 'dst': str(msg['src']),
                        'leader': str(self.currentLeader), 'type': 'redirect',
                        'MID': str(msg['MID'])}
        if len(response) > 0:
            self.sendMessage(response)

    def validMessage(self, msg):
        return msg['src'] and msg['dst'] and msg['type'] and msg['leader']

    def sendMessage(self, message):
        printMessage = False
        if self.printMessage:
            print str(message) + " TIME: " + str(time.time()) + " MSG# " + str(self.messageCount)
        self.my_socket.send(json.dumps(message))
        self.messageCount += 1

    ########################
    ##                    ##
    ##     HEARTBEATS     ##
    ##                    ##
    ########################

    def handleHeartbeat(self, msg):
        """
        if msg['get']:
            messageId = msg['get']['MID']
            if self.node_type == "follower":
                key = msg['get']['key']
                if self.dictionary.has_key(key):
                    val = {}
                    if self.dictionary.get(key):
                        val = {}
                    getResponse = {'MID': messageId, 'key': key, 'value': {}}
                else:
                    getResponse = {'MID': messageId, 'key': key, 'value': ''}
            elif self.node_type == "leader":
                val = msg['get']['value']
                for req in self.getRequests:
                    if req.messageId == messageId and req.value == val:
                        req.ack(msg['src'])
                        if req.quorumMet(self.quorum):
                            self.confirmMessage(req, 'get')

                            self.getRequests.remove(req)
                        break
        """

        if msg['term'] and msg['appendEntries']:
            getResponse = {}
            message = {}
            if msg['term'] > self.my_state.term:
                self.my_state.toTerm(msg['term'])
                self.node_type = "follower"
                self.currentLeader = str(msg['leader'])
                message = {'src': self.my_id, 'dst': msg['src'], 'leader': self.currentLeader,
                           'term': self.my_state.term, 'type': 'heartbeat',
                           'appendEntries': {'status': 'fail', 'pPending': self.my_state.pPending,
                                             'pCommitted': self.my_state.pCommitted, "entries": {}}}
                self.sendMessage(message)
                self.failAllRequests()
            elif msg['term'] == self.my_state.term:
                if self.node_type == "leader":
                    pPend = msg['appendEntries']['pPending']
                    pComm = msg['appendEntries']['pCommitted']
                    node_state = self.other_node_states[self.other_node_states_dict.get(msg['src'])]
                    node_state.pPending = pPend
                    node_state.pCommitted = pComm
                    if msg['appendEntries']['status'] == "ok":
                        node_state.status = "ok"
                        if pPend >= node_state.pPending and pComm == node_state.pCommitted:
                            if pPend - pComm > 0:
                                for i in range(pPend - pComm):
                                    key = self.requestLog[i + pComm]['key']
                                    value = self.requestLog[i + pComm]['value']['value']
                                    for req in self.putRequests:
                                        if req.key == key and req.value == value:
                                            req.ack(msg['src'])
                                            if req.quorumMet(self.quorum) and not req.confirmed:
                                                # print "Committing entry: 'key: " + str(key) + ", 'value': " + str(value) + " TIME: " + str(time.time()) + " MSG# " + str(self.messageCount)
                                                self.dictionary[key] = {'value': value, 'term': self.my_state.term}
                                                self.confirmMessage(req, 'put')
                                                req.confirmed = True
                                            if req.num_acked_nodes == len(self.other_node_ids):
                                                self.putRequests.remove(req)
                                            break
                                self.my_state.pCommitted = pPend
                    elif msg['appendEntries']['status'] == "fail":
                        node_state.status = "fail"
                    if len(msg['get']) > 0:
                        getResponses = []
                        getReqs = msg['get']
                        for req in getReqs:
                            # print str(msg)
                            messageId = req['MID']
                            # print req['value']['value']
                            if len(req['value']) > 0:
                                val = req['value']
                                # print val
                                for num in range(len(self.getRequests)):
                                    # print str(self.getRequests[num].value) + " == " + str(val)
                                    if self.getRequests[num].messageId == messageId and self.getRequests[num].value == val:
                                        #print str(self.getRequests[num].value) + " == " + str(val)
                                        self.getRequests[num].ack(msg['src'])
                                        if self.getRequests[num].quorumMet(self.quorum) and not self.getRequests[num].confirmed:
                                            self.confirmMessage(self.getRequests[num], 'get')
                                            self.getRequests[num].confirmed = True
                                        if self.getRequests[num].num_acked_nodes >= len(self.other_node_ids):
                                            self.getRequests.remove(self.getRequests[num])
                                        break
                elif self.node_type == "follower":
                    self.currentLeader = str(msg['leader'])
                    dest = str(msg['src'])
                    pPend = msg['appendEntries']['pPending']
                    pComm = msg['appendEntries']['pCommitted']
                    msgEntries = msg['appendEntries']['entries']
                    if msg['appendEntries']['status'] == "ok":
                        if self.my_state.pCommitted == pComm and self.my_state.pPending < pPend:
                            for i in range(pPend - self.my_state.pPending):
                                self.requestLog.append(msgEntries[i])
                            self.my_state.pPending = pPend
                            message = {'src': self.my_id, 'dst': dest, 'leader': self.currentLeader,
                                       'term': self.my_state.term, 'type': 'heartbeat',
                                       'appendEntries': {'status': 'ok', 'pPending': self.my_state.pPending,
                                                         'pCommitted': self.my_state.pCommitted, "entries": {}}, 'get': {}}
                        elif self.my_state.pPending <= pPend and self.my_state.pCommitted < pComm:
                            if self.my_state.pPending > pComm:
                                for i in range(pComm - self.my_state.pCommitted):
                                    key = self.requestLog[i + self.my_state.pCommitted]['key']
                                    value = self.requestLog[i + self.my_state.pCommitted]['value']['value']
                                    self.dictionary[key] = {'value': value, 'term': self.my_state.term}
                                self.my_state.pCommitted = pComm
                                message = {'src': self.my_id, 'dst': dest, 'leader': self.currentLeader,
                                           'term': self.my_state.term, 'type': 'heartbeat',
                                           'appendEntries': {'status': 'ok', 'pPending': self.my_state.pPending,
                                                             'pCommitted': self.my_state.pCommitted, "entries": {}}, 'get': {}}
                            else:
                                message = {'src': self.my_id, 'dst': dest, 'leader': self.currentLeader,
                                           'term': self.my_state.term, 'type': 'heartbeat',
                                           'appendEntries': {'status': 'fail', 'pPending': self.my_state.pPending,
                                                             'pCommitted': self.my_state.pCommitted, "entries": {}},
                                           'get': {}}
                        elif self.my_state.pCommitted == pComm and self.my_state.pPending == pPend:
                            message = {'src': self.my_id, 'dst': dest, 'leader': self.currentLeader,
                                       'term': self.my_state.term, 'type': 'heartbeat',
                                       'appendEntries': {'status': 'ok', 'pPending': self.my_state.pPending,
                                                         'pCommitted': self.my_state.pCommitted, "entries": {}},
                                       'get': {}}
                        else:
                            message = {'src': self.my_id, 'dst': dest, 'leader': self.currentLeader,
                                       'term': self.my_state.term, 'type': 'heartbeat',
                                       'appendEntries': {'status': 'fail', 'pPending': self.my_state.pPending,
                                                         'pCommitted': self.my_state.pCommitted, "entries": {}}, 'get': {}}
                    elif msg['appendEntries']['status'] == "override":
                        entrySubArray = self.requestLog[:pComm]
                        for i in range(pPend - self.my_state.pCommitted):
                            entrySubArray.append(msgEntries[i])
                        self.requestLog = entrySubArray
                        for i in range(pComm - self.my_state.pCommitted):
                            key = self.requestLog[i + self.my_state.pCommitted]['key']
                            value = self.requestLog[i + self.my_state.pCommitted]['value']['value']
                            self.dictionary[key] = {'value': value, 'term': self.my_state.term}
                        self.my_state.pPending = pPend
                        self.my_state.pCommitted = pComm
                        message = {'src': self.my_id, 'dst': dest, 'leader': self.currentLeader,
                                   'term': self.my_state.term, 'type': 'heartbeat',
                                   'appendEntries': {'status': 'ok', 'pPending': self.my_state.pPending,
                                                     'pCommitted': self.my_state.pCommitted, "entries": {}}, 'get': {}}
                    if len(msg['get']) > 0:
                        getResponses = []
                        getReqs = msg['get']
                        for req in getReqs:
                            messageId = req['MID']
                            key = req['key']
                            if self.dictionary.has_key(key):
                                getResponse = {'MID': messageId, 'key': key, 'value': self.dictionary.get(key)['value']}
                                getResponses.append(getResponse)
                            else:
                                getResponse = {'MID': messageId, 'key': key, 'value': {}}
                                getResponses.append(getResponse)
                            message['get'] = getResponses
                    self.sendMessage(message)

    def failAllRequests(self):
        for greq in self.getRequests:
            message = {'src': str(self.my_id), 'dst': str(greq.source),
                        'leader': str(self.currentLeader), 'type': 'redirect',
                        'MID': str(greq.messageId)}
            self.sendMessage(message)
        for preq in self.putRequests:
            message = {'src': str(self.my_id), 'dst': str(preq.source),
                       'leader': str(self.currentLeader), 'type': 'redirect',
                       'MID': str(preq.messageId)}
            self.sendMessage(message)


    def heartbeat(self):
        pPend = self.my_state.pPending
        pComm = self.my_state.pCommitted
        entries = []
        getRequest = None
        if len(self.getRequests) > 0:
            getRequest = []
            if len(self.getRequests) > self.maxGetReqs:
                for i in range(self.maxGetReqs):
                    if not self.getRequests[i].confirmed:
                        getRequest.append(self.getRequests[i].getEntry())
            else:
                for req in self.getRequests:
                    if not req.confirmed:
                        getRequest.append(req.getEntry())
        message = {}
        for id in self.other_node_ids:
            node_state = self.other_node_states[self.other_node_states_dict.get(id)]
            node_pPend = node_state.pPending
            node_pComm = node_state.pCommitted
            if node_state.status == "ok":
                if pComm != pPend:
                    entries = self.requestLog[pComm:pPend]
                if getRequest is not None:
                    message = {"src": self.my_id, "dst": id, "leader": self.currentLeader, "type": "heartbeat",
                               "term": self.my_state.term,
                               "appendEntries": {
                                   "status": "ok", "pPending": pPend, "pCommitted": pComm, "entries": entries},
                               "get": getRequest}
                else:
                    message = {"src": self.my_id, "dst": id, "leader": self.currentLeader, "type": "heartbeat",
                               "term": self.my_state.term,
                               "appendEntries": {
                                   "status": "ok", "pPending": pPend, "pCommitted": pComm, "entries": entries}, 'get': []}
            elif node_state.status == "fail":
                entries = self.requestLog[node_pComm:pPend]
                if getRequest is not None:
                    message = {"src": self.my_id, "dst": id, "leader": self.currentLeader, "type": "heartbeat",
                               "term": self.my_state.term,
                               "appendEntries": {"status": "override", "pPending": pPend, "pCommitted": pComm,
                                                 "entries": entries}, "get": getRequest}
                else:
                    message = {"src": self.my_id, "dst": id, "leader": self.currentLeader, "type": "heartbeat",
                               "term": self.my_state.term,
                               "appendEntries": {"status": "override", "pPending": pPend, "pCommitted": pComm,
                                                 "entries": entries}, 'get': []}

            self.sendMessage(message)


this_node = RaftNode(sys.argv[1], sys.argv[2:])

# print("Num Nodes: " + str(len(sys.argv[2:])))
# print("Quorum: " + str(this_node.quorum))

# Connect to the network. All messages to/from other replicas and clients will
# occur over this socket

electionTimer = time.time()
heartbeatTimer = electionTimer
deltaTime = 0
deltaHeartbeat = 0

# timeouts
heartbeatTimeout = 0.04

while True:

    #ready = select.select([this_node.my_socket], [], [], this_node.electionTimeout)[0]

    # logic for checking for election timeouts
    currentTime = time.time()
    deltaTime = currentTime - electionTimer
    deltaHeartbeat = currentTime - heartbeatTimer

    if deltaTime >= this_node.electionTimeout and this_node.node_type != "leader":
        electionTimer = currentTime
        deltaTime = 0
        this_node.selfElect()
    elif deltaHeartbeat >= heartbeatTimeout and this_node.node_type == "leader":
        heartbeatTimer = currentTime
        # print "Heartbeat{'leader': " + str(this_node.my_id) + ", 'time': " + str(currentTime) + "}"
        deltaHeartbeat = 0
        this_node.heartbeat()

    ready = select.select([this_node.my_socket], [], [], 0.06)[0]
    if this_node.my_socket in ready:
        msg_raw = this_node.my_socket.recv(32768)

        if len(msg_raw) > 0:
            if this_node.node_type != 'leader':
                electionTimer = currentTime
                deltaTime = 0
                this_node.resetElectionTimeout()
            msg = json.loads(msg_raw)
            if this_node.validMessage(msg):
                src = msg['src']
                if src not in this_node.other_node_ids:
                    this_node.messageCount += 1
                    # For now, ignore get() and put() from clients

                    type = str(msg['type'])
                    if this_node.printMessage:
                        print "********************************"
                        print str(msg) + " TIME: " + str(time.time()) + " MSG# " + str(this_node.messageCount)
                        print "********************************"
                    if type == 'get':
                        this_node.handleGet(msg)
                    if type == 'put':
                        this_node.handlePut(msg)

                # Handle election voting
                else:
                    if str(msg['type']) == 'vote':
                        this_node.handleVote(msg)
                    elif str(msg['type']) == 'voteRequest':
                        this_node.handleVoteRequest(msg)
                    elif str(msg['type']) == 'heartbeat':
                        this_node.handleHeartbeat(msg)
            else:
                this_node.failMessage(msg)


        """
        if this_node.node_type == "leader":
            #timer = currentTime
            print "Heartbeat{'leader': " + str(this_node.my_id) + ", 'time': " + str(electionTimer + deltaTime) + "}"
            this_node.heartbeat()

    if deltaTime >= this_node.electionTimeout:
        timer = currentTime
        this_node.selfElect()
    """

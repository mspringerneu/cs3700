#!/usr/bin/env python3

import sys
import socket
import select
import time
import json
import random
from enum import Enum
from collections import deque


class ReplicaState:
    def __init__(self):
        self.id = id
        self.term = 0
        self.votes = 1
        self.pPending = 0
        self.pCommitted = 0

    def nextTerm(self):
        self.term += 1
        self.votes = 1

    def toTerm(self, term):
        if term > self.term:
            self.term = term
            self.votes = 1


class AppendEntry:
    def __init__(self, msg, term):
        self.status = 'pending'
        self.source = msg['src']
        self.acked_nodes = []
        self.num_acked_nodes = 1
        self.quorum = False
        self.key = msg['key']
        self.value = msg['value']
        self.messageId = msg['MID']
        self.term = term

    def quorumMet(self, quorum):
        if quorum > self.num_acked_nodes:
            self.quorum = False
        else:
            self.quorum = True
        return self.quorum

    def ack(self, replica_id):
        if replica_id not in self.acked_nodes:
            self.acked_nodes.append(replica_id)
            self.num_acked_nodes += 1


class RaftNode:
    def __init__(self, my_id, other_node_ids):
        self.my_id = my_id
        self.my_state = ReplicaState()
        self.my_socket = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
        self.my_socket.connect(self.my_id)
        self.raft_size = len(other_node_ids) + 1
        self.quorum = (self.raft_size / 2) + 1
        self.other_node_ids = other_node_ids
        self.other_node_states = dict()
        for replicaId in other_node_ids:
            self.other_node_states.update(replicaId, ReplicaState())
        self.requestLog = deque()
        self.dictionary = dict()
        self.node_type = State.follower.value
        self.vote_tally = 0
        self.appendResponses = 0
        self.currentLeader = ""
        self.electionTimeout = 0.15
        self.resetElectionTimeout()

    def resetElectionTimeout(self):
        self.electionTimeout = float((random.randrange(150, 300)) / 1000)

    def castVote(self, candidate, dest):
        if self.my_state.votes > 0:
            if dest == "FFFF":
                for replica_id in self.other_node_ids:
                    vote = json.loads(
                        {'src': self.my_id, 'dest': replica_id, 'type': 'vote', 'term': self.my_state.term,
                         'candidate': candidate})
                    self.my_socket.send(vote)
                    self.my_state.votes = 0
            else:
                vote = json.loads({'src': self.my_id, 'dest': dest, 'type': 'vote', 'term': self.my_state.term,
                                   'candidate': candidate})
                self.my_socket.send(vote)
                self.my_state.votes = 0

    def selfElect(self):
        self.resetElectionTimeout()
        self.node_type = State.candidate.value
        self.my_state.nextTerm()
        self.vote_tally = 1
        self.my_state.votes = 0
        self.castVote(self.my_id, "FFFF")

    def handleVote(self, msg):
        term = msg['term']
        candidate = msg['candidate']
        if self.node_type == State.follower.value:
            if term > self.my_state.term:
                self.my_state.toTerm(term)
                self.castVote(candidate, candidate)
            elif term == self.my_state.term and self.my_state.votes > 0:
                self.castVote(candidate, candidate)
        elif self.node_type == State.candidate.value:
            if term > self.my_state.term:
                self.node_type = State.follower.value
                self.my_state.toTerm(term)
                self.castVote(candidate, candidate)
            elif term == self.my_state.term and candidate == self.my_id:
                self.vote_tally += 1
                if self.vote_tally == self.quorum:
                    self.becomeLeader()

    def becomeLeader(self):
        self.node_type = State.leader.value
        self.vote_tally = 0
        self.currentLeader = self.my_id
        self.appendResponses = 0

    def handlePut(self, msg):
        global currentLeader
        global requestLog
        global my_state
        # todo: check fail/ok conditions
        if msg['key'] and msg['value']:
            if self.node_type == State.leader.value:
                entry = AppendEntry(msg, self.my_state.term)
                entry.quorumMet(self.quorum)
                self.requestLog.append(entry)
                self.my_state.pPending += 1

            else:
                self.failMessage(msg)
        else:
            self.failMessage(msg)

    def failMessage(self, msg):
        response = {}
        # fail message
        if self.node_type == State.leader.value:
            self.my_socket.send(
                json.dumps({"src": self.my_id, "dst": msg['src'], "leader": self.currentLeader, "type": "fail",
                            "MID": msg['MID']}))
        # redirect message
        elif msg['dest'] == self.my_id:
            self.my_socket.send(
                json.dumps({"src": self.my_id, "dst": msg['src'], "leader": self.currentLeader, "type": "redirect",
                            "MID": msg['MID']}))

    def handleGet(self, msg):
        global currentLeader
        response = {}
        value = ""
        if msg['key']:
            if state == State.leader.value:
                if msg['key'] in dictionary.keys():
                    value = dictionary.get(msg['key'])
                    self.my_socket.send(
                        json.dumps({"src": msg['dest'], "dst": msg['src'], "leader": currentLeader, "type": "ok",
                                    "MID": msg['MID'],
                                    "value": value}))
                else:
                    self.my_socket.send(
                        json.dumps({"src": msg['dest'], "dst": msg['src'], "leader": currentLeader, "type": "ok",
                                    "MID": msg['MID'],
                                    "value": value}))
            else:
                self.failMessage(msg)
        else:
            self.failMessage(msg)

    def validMessage(self, msg):
        return msg['src'] and msg['dest'] and msg['type'] and msg['leader']

    def writePut(key, value):
        return False

    def handleHeartbeat(self, msg):
        if msg['term'] and msg['state'] and msg['appendEntries']:
            if self.node_type == State.leader.value:

            elif self.node_type == State.follower.value:
                if msg['term'] > self.my_state.term:
                    self.my_state.toTerm(msg['term'])
                    self.currentLeader = msg['src']
                    self.failHeartbeat()
                elif msg['term'] == self.my_state.term:
                    if not msg['src'] == self.currentLeader:
                        self.currentLeader = msg['src']
                    msgPend = msg['appendEntries']['pPending']
                    msgComm = msg['appendEntries']['pCommitted']
                    if msgPend == self.my_state.pPending and msgComm == self.my_state.pCommitted:
                        for entry in msg['appendEntries']['entries']:
                            self.requestLog.append(entry)
            if msg['term'] > currentTerm:
                updateTerm(currentTerm, msg['src'])
            elif state == State.follower.value:
                if msg['term'] == currentTerm and msg['src'] == currentLeader:
                    resetElectionTimeout()
                if msg['state'] == 'ready' and len(msg['appendEntries']):
                    uncommitted = msg['appendEntries']
                elif msg['state'] == 'commit':
                    dictionary.update(uncommitted)

    def heartbeat(self):
        pPend = self.my_state.pPending
        pComm = self.my_state.pCommitted
        entries = self.requestLog[pComm:pPend]
        hbEntries = []
        message = {}
        for i in range(len(entries)):
            hbEntries.append({"key": entries[i].key, "value": entries[i].value})
        for replica_id in self.other_node_ids:
            message = {"src": self.my_id, "dst": replica_id, "leader": self.currentLeader, "type": "heartbeat",
                       "term": self.my_state.term,
                       "appendEntries": {"pPending": pPend, "pCommitted": pComm, "entries": hbEntries}}


# Your ID number
my_id = sys.argv[1]

# The ID numbers of all the other replicas
replica_ids = sys.argv[2:]

# number of replicas
replica_count = len(replica_ids) + 1

# majority
quorum = (replica_count / 2) + 1

# the state of this replica
my_state = ReplicaState(my_id)

# the states of other replicas
replica_states = []
for replica_id in replica_ids:
    replica_states.append(ReplicaState(replica_id))

# dictionary
requestLog = deque()

# uncommitted changes
dictionary = dict()


# is the node a leader (all nodes start as follower
class State(Enum):
    follower = 0
    candidate = 1
    leader = 2


state = State.follower.value

# what term are we in
currentTerm = 0

# how many votes you can cast (1 per election)
votes = 1

# how many votes have you received
tally = 0

# how many replicas have committed
commits = 0

# who is the leader
currentLeader = ""

this_node = RaftNode(my_id, replica_ids)

# Connect to the network. All messages to/from other replicas and clients will
# occur over this socket
sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
sock.connect(this_node.my_id)

timer = time.time()
deltaTime = 0

last = 0

# timeouts
electionTimeout = 0.15
heartbeatTimeout = 0.05


def validMessage(msg):
    return msg['src'] and msg['dest'] and msg['type'] and msg['leader']


while True:
    currentTime = time.time()
    deltaTime = currentTime - timer
    if deltaTime >= this_node.electionTimeout:
        this_node.selfElect()

    ready = select.select([sock], [], [], heartbeatTimeout)[0]

    if sock in ready:
        msg_raw = sock.recv(32768)

        if len(msg_raw) == 0: continue
        msg = json.loads(msg_raw)

        if validMessage(msg):
            # For now, ignore get() and put() from clients
            if msg['type'] == 'get':
                this_node.handleGet(msg)

            elif msg['type'] == 'put':
                this_node.handlePut(msg)

            # Handle election voting
            elif msg['type'] == 'vote':
                this_node.handleVote(msg)

            elif msg['type'] == 'heartbeat':
                this_node.handleHeartbeat()
                print('%s received a NOOP from %s' % (msg['dst'], msg['src']))
        else:
            this_node.failMessage(msg)

        if this_node.node_type == State.leader.value:
            for id in replica_ids:
                msg = {'src': my_id, 'dest': id, 'type': 'heartbeat', 'term': term}

    clock = time.time()
    if clock - last > 2:
        # Send a no-op message to a random peer every two seconds, just for fun
        # You definitely want to remove this from your implementation
        msg = {'src': my_id, 'dst': random.choice(replica_ids), 'leader': 'FFFF', 'type': 'noop'}
        sock.send(json.dumps(msg))
        print('%s sending a NOOP to %s' % (msg['src'], msg['dst']))
        last = clock

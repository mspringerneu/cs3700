#!/usr/bin/env python

import sys
import socket
import select
import time
import json
import random
from collections import deque


class ReplicaState:
    def __init__(self, index):
        self.index = index
        self.term = 0
        self.votes = 1
        self.pPending = 0
        self.pCommitted = 0
        self.status = "ok"

    def nextTerm(self):
        self.term += 1
        self.votes = 1

    def toTerm(self, term):
        if term > self.term:
            self.term = term
            self.votes = 1


class GetRequest:
    def __init__(self, msg, term):
        self.source = str(msg['src'])
        self.acked_nodes = []
        self.num_acked_nodes = 1
        self.quorum = False
        self.key = str(msg['key'])
        self.value = ""
        self.messageId = str(msg['MID'])
        self.term = term
        self.confirmed = False

    def quorumMet(self, quorum):
        if quorum > self.num_acked_nodes:
            self.quorum = False
        else:
            self.quorum = True
        return self.quorum

    def ack(self, replica_id):
        if replica_id not in self.acked_nodes:
            self.acked_nodes.append(replica_id)
            self.num_acked_nodes += 1

    def setValue(self, val):
        self.value = val

    def getEntry(self):
        return {"MID": self.messageId, "key": self.key, "value": ""}


class PutRequest:
    def __init__(self, msg, term):
        self.source = str(msg['src'])
        self.acked_nodes = []
        self.num_acked_nodes = 1
        self.quorum = False
        self.key = str(msg['key'])
        self.value = str(msg['value'])
        self.messageId = str(msg['MID'])
        self.term = term
        self.confirmed = False

    def quorumMet(self, quorum):
        if quorum > self.num_acked_nodes:
            self.quorum = False
        else:
            self.quorum = True
        return self.quorum

    def ack(self, replica_id):
        if replica_id not in self.acked_nodes:
            self.acked_nodes.append(replica_id)
            self.num_acked_nodes += 1

    def getLogEntry(self):
        return {'key': self.key, 'value': {'value': self.value, 'term': self.term}}


class RaftNode:
    def __init__(self, my_id, other_node_ids):
        self.my_id = my_id
        self.my_state = ReplicaState("myState")
        self.my_socket = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
        self.my_socket.connect(self.my_id)
        self.raft_size = len(other_node_ids) + 1
        self.quorum = (self.raft_size / 2) + 1
        self.other_node_ids = []
        self.other_node_states_dict = dict()
        self.other_node_states = []
        for i in range(len(other_node_ids)):
            node_id = other_node_ids[i]
            self.other_node_ids.append(other_node_ids[i])
            state = ReplicaState(i)
            self.other_node_states.append(state)
            self.other_node_states_dict[node_id] = i
        self.getRequests = []
        self.putRequests = []
        self.pendingRequests = []
        self.requestLog = []
        self.dictionary = dict()
        self.node_type = "follower"
        self.vote_tally = 0
        self.appendResponses = 0
        self.currentLeader = "FFFF"
        self.electionTimeout = 0.3
        self.resetElectionTimeout()
        self.sendMessages = []

    ##############################
    ##                          ##
    ##     ELECTION HANDLING    ##
    ##                          ##
    ##############################

    def resetElectionTimeout(self):
        # set the election timeout to a random number between 0.150 and 0.300
        self.electionTimeout = float(float(random.randrange(150, 300))/1000)

    def requestVotes(self):
        for replica_id in self.other_node_ids:
            vote = {'src': self.my_id, 'dst': replica_id, 'type': 'voteRequest', 'leader': self.currentLeader,
                    'term': self.my_state.term,
                    'candidate': self.my_id}
            self.sendMessage(vote)
        self.my_state.votes = 0

    def castVote(self, candidate, dst):
        if self.my_state.votes > 0:
            vote = {'src': self.my_id, 'dst': dst, 'type': 'vote', 'leader': self.currentLeader, 'term': self.my_state.term,
                               'candidate': candidate}
            self.sendMessage(vote)
            self.my_state.votes = 0

    def selfElect(self):
        #self.resetElectionTimeout()
        self.node_type = "candidate"
        self.my_state.nextTerm()
        self.currentLeader = self.my_id
        # votes received
        self.vote_tally = 1
        # print "ELECTION{'term': " + str(self.my_state.term) + ", 'candidate': " + str(self.my_id) + ", 'time': " + str(currentTime) + "}"
        self.requestVotes()

    def handleVote(self, msg):
        term = msg['term']
        candidate = str(msg['candidate'])
        if self.node_type == "candidate":
            if term == self.my_state.term and candidate == self.my_id:
                self.vote_tally += 1
                if self.vote_tally >= self.quorum:
                    self.becomeLeader()

    def handleVoteRequest(self, msg):
        term = msg['term']
        candidate = str(msg['candidate'])
        if term > self.my_state.term:
            self.node_type = "follower"
            self.my_state.toTerm(term)
            self.currentLeader = candidate
            self.castVote(candidate, candidate)
        elif term == self.my_state.term and self.my_state.votes > 0:
            self.castVote(candidate, candidate)

    def becomeLeader(self):
        #print("New leader: " + str(self.my_id) + ", Quorum: " + str(self.quorum))
        self.node_type = "leader"
        self.vote_tally = 0
        self.currentLeader = self.my_id

    ##############################
    ##                          ##
    ##     GET/PUT REQUESTS     ##
    ##                          ##
    ##############################

    def handleGet(self, msg):
        if msg['key']:
            if self.node_type == "leader":
                request = GetRequest(msg, self.my_state.term)
                if msg['key'] in self.dictionary.keys():
                    request.setValue(self.dictionary.get(msg['key']))

                # if there is only one node in the raft
                if request.quorumMet(self.quorum):
                    self.confirmMessage(request, "get")
                else:
                    self.getRequests.append(request)
            else:
                self.failMessage(msg)
        else:
            self.failMessage(msg)

    def confirmMessage(self, request, reqType):
        response = {}
        uni = True
        if reqType == 'get':
            if uni:
                response = {'src': str(self.my_id), 'dst': str(request.source),
                            'leader': str(self.currentLeader), 'type': 'ok',
                            'MID': str(request.messageId), 'value': str(request.value)}
            else:
                response = {'src': str(self.my_id), 'dst': str(request.source),
                            'leader': str(self.currentLeader), 'type': 'ok',
                            'MID': str(request.messageId), 'value': str(request.value)}
        elif reqType == 'put':
            if uni:
                response = {'src': str(self.my_id), 'dst': str(request.source),
                            'leader': str(self.currentLeader), 'type': 'ok',
                            'MID': str(request.messageId)}
            else:
                response = {'src': str(self.my_id), 'dst': str(request.source),
                            'leader': str(self.currentLeader), 'type': 'ok',
                            'MID': str(request.messageId)}
        if len(response) > 0:
            # print "################################"
            # print str(response)
            # print "################################"
            self.sendMessage(response)

    def handlePut(self, msg):
        # todo: check fail/ok conditions
        if msg['key'] and msg['value']:
            if self.node_type == "leader":
                request = PutRequest(msg, self.my_state.term)
                entry = request.getLogEntry()
                self.requestLog.append(entry)
                self.my_state.pPending += 1

                # if there is only one node in the raft
                if request.quorumMet(self.quorum):
                    self.confirmMessage(request, "put")
                    self.my_state.pCommitted += 1
                else:
                    self.putRequests.append(request)

            else:
                self.failMessage(msg)
        else:
            self.failMessage(msg)

    def failMessage(self, msg):
        # todo: might have to change else case
        response = {}
        uni = True
        # fail message
        if self.node_type == "leader":
            if uni:
                response = {'src': str(self.my_id), 'dst': str(msg['src']), 'leader': str(self.currentLeader), 'type': 'ok',
                            'MID': str(msg['MID'])}
            else:
                response = {'src': str(self.my_id), 'dst': str(msg['src']),
                        'leader': str(self.currentLeader), 'type': 'redirect',
                        'MID': str(msg['MID'])}
        # redirect message
        elif msg['dst'] == self.my_id:
            if uni:
                response = {'src': str(self.my_id), 'dst': str(msg['src']),
                        'leader': str(self.currentLeader), 'type': 'redirect',
                        'MID': str(msg['MID'])}
            else:
                response = {'src': str(self.my_id), 'dst': str(msg['src']),
                        'leader': str(self.currentLeader), 'type': 'redirect',
                        'MID': str(msg['MID'])}
        if len(response) > 0:
            self.sendMessage(response)

    def validMessage(self, msg):
        return msg['src'] and msg['dst'] and msg['type'] and msg['leader']

    def writePut(key, value):
        return False

    def sendMessage(self, message):
        printMessage = False
        if printMessage:
            print str(message) + " TIME: " + str(time.time())
        self.my_socket.send(json.dumps(message))

    ########################
    ##                    ##
    ##     HEARTBEATS     ##
    ##                    ##
    ########################

    def handleHeartbeat(self, msg):
        """
        if msg['get']:
            messageId = msg['get']['MID']
            if self.node_type == "follower":
                key = msg['get']['key']
                if self.dictionary.has_key(key):
                    val = {}
                    if self.dictionary.get(key):
                        val = {}
                    getResponse = {'MID': messageId, 'key': key, 'value': {}}
                else:
                    getResponse = {'MID': messageId, 'key': key, 'value': ''}
            elif self.node_type == "leader":
                val = msg['get']['value']
                for req in self.getRequests:
                    if req.messageId == messageId and req.value == val:
                        req.ack(msg['src'])
                        if req.quorumMet(self.quorum):
                            self.confirmMessage(req, 'get')

                            self.getRequests.remove(req)
                        break
        """

        if msg['term'] and msg['appendEntries']:
            getResponse = {}
            message = {}
            if msg['term'] > self.my_state.term:
                self.my_state.toTerm(msg['term'])
                self.node_type = "follower"
                self.currentLeader = str(msg['leader'])
                message = {'src': self.my_id, 'dst': msg['src'], 'leader': self.currentLeader,
                           'term': self.my_state.term, 'type': 'heartbeat',
                           'appendEntries': {'status': 'fail', 'pPending': self.my_state.pPending,
                                             'pCommitted': self.my_state.pCommitted, "entries": {}}}
                self.sendMessage(message)
                self.failAllRequests()
            elif msg['term'] == self.my_state.term:
                if self.node_type == "leader":
                    pPend = msg['appendEntries']['pPending']
                    pComm = msg['appendEntries']['pCommitted']
                    node_state = self.other_node_states[self.other_node_states_dict.get(msg['src'])]
                    node_state.pPending = pPend
                    node_state.pCommitted = pComm
                    if msg['appendEntries']['status'] == "ok":
                        node_state.status = "ok"
                        if pPend >= node_state.pPending and pComm == node_state.pCommitted:
                            if pPend - pComm > 0:
                                for i in range(pPend - pComm):
                                    key = self.requestLog[i + pComm]['key']
                                    value = self.requestLog[i + pComm]['value']['value']
                                    for req in self.putRequests:
                                        if req.key == key and req.value == value:
                                            req.ack(msg['src'])
                                            if req.quorumMet(self.quorum) and not req.confirmed:
                                                print "Committing entry: 'key: " + str(key) + ", 'value': " + str(value)
                                                self.dictionary[key] = value
                                                self.confirmMessage(req, 'put')
                                                req.confirmed = True
                                            if req.num_acked_nodes == len(self.other_node_ids):
                                                self.putRequests.remove(req)
                                            break
                                self.my_state.pCommitted = pPend
                    elif msg['appendEntries']['status'] == "fail":
                        node_state.status = "fail"
                    if len(msg['get']) > 0:
                        getResponses = []
                        for req in msg['get']:
                            # print str(msg)
                            messageId = req['MID']
                            # print req['value']['value']
                            val = req['value']['value']
                            # print val
                            for greq in self.getRequests:
                                if greq.messageId == req['MID'] and greq.value == val:
                                    greq.ack(msg['src'])
                                    if greq.quorumMet(self.quorum) and not greq.confirmed:
                                        self.confirmMessage(greq, 'get')
                                        greq.confirmed = True
                                    if greq.num_acked_nodes >= len(self.other_node_ids):
                                        self.getRequests.remove(greq)
                elif self.node_type == "follower":
                    self.currentLeader = str(msg['leader'])
                    dest = str(msg['src'])
                    pPend = msg['appendEntries']['pPending']
                    pComm = msg['appendEntries']['pCommitted']
                    msgEntries = msg['appendEntries']['entries']
                    if msg['appendEntries']['status'] == "ok":
                        if self.my_state.pCommitted == pComm and self.my_state.pPending < pPend:
                            for i in range(pPend - self.my_state.pPending):
                                self.requestLog.append(msgEntries[i])
                            self.my_state.pPending = pPend
                            message = {'src': self.my_id, 'dst': dest, 'leader': self.currentLeader,
                                       'term': self.my_state.term, 'type': 'heartbeat',
                                       'appendEntries': {'status': 'ok', 'pPending': self.my_state.pPending,
                                                         'pCommitted': self.my_state.pCommitted, "entries": {}}, 'get': {}}
                        elif self.my_state.pPending <= pPend and self.my_state.pCommitted < pComm:
                            for i in range(pComm - self.my_state.pCommitted):
                                key = self.requestLog[i + self.my_state.pCommitted]['key']
                                value = self.requestLog[i + self.my_state.pCommitted]['value']['value']
                                # print "Committing entry: 'key: " + str(key) + ", 'value': " + str(value)
                                self.dictionary[key] = {'value': value, 'term': self.my_state.term}
                            self.my_state.pCommitted = pComm
                            message = {'src': self.my_id, 'dst': dest, 'leader': self.currentLeader,
                                       'term': self.my_state.term, 'type': 'heartbeat',
                                       'appendEntries': {'status': 'ok', 'pPending': self.my_state.pPending,
                                                         'pCommitted': self.my_state.pCommitted, "entries": {}}, 'get': {}}
                        elif self.my_state.pCommitted == pComm and self.my_state.pPending == pPend:
                            message = {'src': self.my_id, 'dst': dest, 'leader': self.currentLeader,
                                       'term': self.my_state.term, 'type': 'heartbeat',
                                       'appendEntries': {'status': 'ok', 'pPending': self.my_state.pPending,
                                                         'pCommitted': self.my_state.pCommitted, "entries": {}},
                                       'get': {}}
                        else:
                            message = {'src': self.my_id, 'dst': dest, 'leader': self.currentLeader,
                                       'term': self.my_state.term, 'type': 'heartbeat',
                                       'appendEntries': {'status': 'fail', 'pPending': self.my_state.pPending,
                                                         'pCommitted': self.my_state.pCommitted, "entries": {}}, 'get': {}}
                    elif msg['appendEntries']['status'] == "override":
                        entrySubArray = self.requestLog[:pComm]
                        for i in range(pPend - self.my_state.pCommitted):
                            entrySubArray.append(msgEntries[i])
                        self.requestLog = entrySubArray
                        for i in range(pComm - self.my_state.pCommitted):
                            key = self.requestLog[i + self.my_state.pCommitted]['key']
                            value = self.requestLog[i + self.my_state.pCommitted]['value']['value']
                            # print "Committing entry: 'key: " + str(key) + ", 'value': " + str(value)
                            self.dictionary[key] = {'value': value, 'term': self.my_state.term}
                        self.my_state.pPending = pPend
                        self.my_state.pCommitted = pComm
                        message = {'src': self.my_id, 'dst': dest, 'leader': self.currentLeader,
                                   'term': self.my_state.term, 'type': 'heartbeat',
                                   'appendEntries': {'status': 'ok', 'pPending': self.my_state.pPending,
                                                     'pCommitted': self.my_state.pCommitted, "entries": {}}, 'get': {}}
                    if len(msg['get']) > 0:
                        getResponses = []
                        for req in msg['get']:
                            messageId = req['MID']
                            key = req['key']
                            if self.dictionary.has_key(key):
                                getResponse = {'MID': messageId, 'key': key, 'value': self.dictionary.get(key)}
                                getResponses.append(getResponse)
                            else:
                                getResponse = {'MID': messageId, 'key': key, 'value': {}}
                                getResponses.append(getResponse)
                            message['get'] = getResponses
                    self.sendMessage(message)

    def failAllRequests(self):
        for greq in self.getRequests:
            message = {'src': str(self.my_id), 'dst': str(greq.source),
                        'leader': str(self.currentLeader), 'type': 'redirect',
                        'MID': str(greq.messageId)}
            self.sendMessage(message)
        for preq in self.putRequests:
            message = {'src': str(self.my_id), 'dst': str(preq.source),
                       'leader': str(self.currentLeader), 'type': 'redirect',
                       'MID': str(preq.messageId)}
            self.sendMessage(message)


    def heartbeat(self):
        pPend = self.my_state.pPending
        pComm = self.my_state.pCommitted
        entries = []
        getRequest = None
        if len(self.getRequests) > 0:
            getRequest = []
            for req in self.getRequests:
                getRequest.append(req.getEntry())
        message = {}
        for id in self.other_node_ids:
            node_state = self.other_node_states[self.other_node_states_dict.get(id)]
            node_pPend = node_state.pPending
            node_pComm = node_state.pCommitted
            if node_state.status == "ok":
                if pComm != pPend:
                    entries = self.requestLog[pComm:pPend]
                if getRequest is not None:
                    message = {"src": self.my_id, "dst": id, "leader": self.currentLeader, "type": "heartbeat",
                               "term": self.my_state.term,
                               "appendEntries": {
                                   "status": "ok", "pPending": pPend, "pCommitted": pComm, "entries": entries},
                               "get": getRequest}
                else:
                    message = {"src": self.my_id, "dst": id, "leader": self.currentLeader, "type": "heartbeat",
                               "term": self.my_state.term,
                               "appendEntries": {
                                   "status": "ok", "pPending": pPend, "pCommitted": pComm, "entries": entries}, 'get': []}
            elif node_state.status == "fail":
                entries = self.requestLog[node_pComm:pPend]
                if getRequest is not None:
                    message = {"src": self.my_id, "dst": id, "leader": self.currentLeader, "type": "heartbeat",
                               "term": self.my_state.term,
                               "appendEntries": {"status": "override", "pPending": pPend, "pCommitted": pComm,
                                                 "entries": entries}, "get": getRequest}
                else:
                    message = {"src": self.my_id, "dst": id, "leader": self.currentLeader, "type": "heartbeat",
                               "term": self.my_state.term,
                               "appendEntries": {"status": "override", "pPending": pPend, "pCommitted": pComm,
                                                 "entries": entries}, 'get': []}

            self.sendMessage(message)


this_node = RaftNode(sys.argv[1], sys.argv[2:])

# print("Num Nodes: " + str(len(sys.argv[2:])))
# print("Quorum: " + str(this_node.quorum))

# Connect to the network. All messages to/from other replicas and clients will
# occur over this socket

electionTimer = time.time()
heartbeatTimer = electionTimer
deltaTime = 0
deltaHeartbeat = 0

# timeouts
heartbeatTimeout = 0.03


def validMessage(msg):
    return msg['src'] and msg['dst'] and msg['type'] and msg['leader']


while True:

    #ready = select.select([this_node.my_socket], [], [], this_node.electionTimeout)[0]

    # logic for checking for election timeouts
    currentTime = time.time()
    deltaTime = currentTime - electionTimer
    deltaHeartbeat = currentTime - heartbeatTimer

    if deltaTime >= this_node.electionTimeout and this_node.node_type != "leader":
        electionTimer = currentTime
        deltaTime = 0
        this_node.selfElect()
    elif deltaHeartbeat >= heartbeatTimeout and this_node.node_type == "leader":
        heartbeatTimer = currentTime
        # print "Heartbeat{'leader': " + str(this_node.my_id) + ", 'time': " + str(currentTime) + "}"
        deltaHeartbeat = 0
        this_node.heartbeat()
    else:
        ready = select.select([this_node.my_socket], [], [], 0.01)[0]
        if this_node.my_socket in ready:
            msg_raw = this_node.my_socket.recv(32768)

            if len(msg_raw) > 0:
                if this_node.node_type != 'leader':
                    electionTimer = currentTime
                    deltaTime = 0
                    this_node.resetElectionTimeout()
                msg = json.loads(msg_raw)
                if validMessage(msg):
                    src = msg['src']
                    if src not in this_node.other_node_ids:

                        # For now, ignore get() and put() from clients

                        type = str(msg['type'])
                        if type == 'get':
                            """
                            print "********************************"
                            print str(msg)
                            print "********************************"
                            """
                            this_node.handleGet(msg)
                        if type == 'put':
                            """
                            print "********************************"
                            print str(msg)
                            print "********************************"
                            """
                            this_node.handlePut(msg)




                    # Handle election voting
                    else:
                        if str(msg['type']) == 'vote':
                            this_node.handleVote(msg)
                        elif str(msg['type']) == 'voteRequest':
                            this_node.handleVoteRequest(msg)
                        elif str(msg['type']) == 'heartbeat':
                            this_node.handleHeartbeat(msg)
                else:
                    this_node.failMessage(msg)

        """
        if this_node.node_type == "leader":
            #timer = currentTime
            print "Heartbeat{'leader': " + str(this_node.my_id) + ", 'time': " + str(electionTimer + deltaTime) + "}"
            this_node.heartbeat()

    if deltaTime >= this_node.electionTimeout:
        timer = currentTime
        this_node.selfElect()
    """

#!/usr/bin/env python

import sys
import socket
import select
import time
import json
import random
from collections import deque


######################################################################
#   CLASS: REPLICASTATE
#
#       ARGUMENTS
#
#           index           - the index of the replica state(to be used by the ReplicaNode that stores it in an array)
#
#       ADDITIONAL STORED VARIABLES
#
#           term            - what term the ReplicaNode thinks it is in
#           votes           - the number of votes the ReplicaNode can still cast this term
#           pPending        - pointer to the where the next pending appendEntry should be placed in the log
#           pCommitted      - pointer to the next pending entry in the log to be committed
#           lastEntryTerm   - term of the last committed request
#           status          - status message to send in heartbeat responses - "ok" if synced with leader, "fail" if not
#
#       METHODS
#
#           nextTerm        - increment the term by 1 and set votes to 1
#           parsePageHTML   - increment to the given term and set votes to 1
#           getEntry        - returns an entry for the state to be passed in a voteRequest
#
class ReplicaState:
    def __init__(self, index):
        self.index = index
        self.term = 0
        self.votes = 1
        self.pPending = 0
        self.pCommitted = 0
        self.lastEntryTerm = 0
        self.status = "ok"

    def nextTerm(self):
        self.term += 1
        self.votes = 1

    def toTerm(self, term):
        if term > self.term:
            self.term = term
            self.votes = 1

    def getEntry(self):
        return {"term": self.term, "pPending": self.pPending,
                "pCommitted": self.pCommitted, 'lastEntryTerm': self.lastEntryTerm}


######################################################################
#   CLASS: GETREQUEST
#
#       ARGUMENTS
#
#           msg             - JSON message from which to create the GetRequest
#           term            - term in which the GetRequest was received
#           quorum          - the number of responses that constitutes a quorum
#
#       ADDITIONAL STORED VARIABLES
#
#           source          - the source of the request
#           acked_nodes     - array of the IDs of ReplicaNodes that have acked the request
#           num_acked_nodes - the number of ReplicaNodes that have acked the request
#           quorumMet       - whether or not the number of ReplicaNodes that acked the request constitutes a quorum
#           key             - dictionary key
#           value           - value of dictionary[key] to be returned to the client
#           messageId       - message Id of the client's request
#           term            - which term the request was made in
#           confirmed       - whether or not a response has been sent to the client
#
#       METHODS
#
#           ack             - add the given replicaId to the array of ackedNodes, increment num_acked_nodes,
#                             determine if a quorum has been met
#           setValue        - set the request's value to the given value
#           getEntry        - returns an entry for the request to be passed in the heartbeat
#
class GetRequest:
    def __init__(self, msg, term, quorum):
        self.term = term
        self.quorum = quorum
        self.source = str(msg['src'])
        self.acked_nodes = []
        self.num_acked_nodes = 1
        self.quorumMet = False
        self.key = str(msg['key'])
        self.value = ""
        self.messageId = str(msg['MID'])
        self.confirmed = False
        self.birth = time.time()

    def ack(self, replica_id, agrees):
        if replica_id not in self.acked_nodes:
            self.acked_nodes.append(replica_id)
            if agrees:
                self.num_acked_nodes += 1
            self.quorumMet = self.num_acked_nodes >= self.quorum

    def setValue(self, value):
        self.value = value

    def getEntry(self):
        return {"MID": self.messageId, "key": self.key, "value": ""}


######################################################################
#   CLASS: PUTREQUEST
#
#       ARGUMENTS
#
#           msg             - JSON message from which to create the GetRequest
#           term            - term in which the GetRequest was received
#           quorum          - the number of responses that constitutes a quorum
#
#       ADDITIONAL STORED VARIABLES
#
#           source          - the source of the request
#           acked_nodes     - array of the IDs of ReplicaNodes that have acked the request
#           num_acked_nodes - the number of ReplicaNodes that have acked the request
#           quorumMet       - whether or not the number of ReplicaNodes that acked the request constitutes a quorum
#           key             - dictionary key
#           value           - value of dictionary[key] to be stored in the dictionary
#           messageId       - message Id of the client's request
#           term            - which term the request was made in
#           confirmed       - whether or not a response has been sent to the client
#
#       METHODS
#
#           ack             - add the given replicaId to the array of ackedNodes, increment num_acked_nodes,
#                             determine if a quorum has been met
#           setValue        - set the request's value to the given value
#           getEntry        - returns an entry for the request to be passed in the heartbeat
#
class PutRequest:
    def __init__(self, msg, term, quorum):
        self.term = term
        self.quorum = quorum
        self.source = str(msg['src'])
        self.acked_nodes = []
        self.num_acked_nodes = 1
        self.quorumMet = False
        self.key = str(msg['key'])
        self.value = str(msg['value'])
        self.messageId = str(msg['MID'])
        self.confirmed = False
        self.birth = time.time()

    def ack(self, replica_id):
        if replica_id not in self.acked_nodes:
            self.acked_nodes.append(replica_id)
            self.num_acked_nodes += 1
            self.quorumMet = self.num_acked_nodes >= self.quorum

    def getLogEntry(self):
        return {'key': self.key, 'value': {'value': self.value, 'term': self.term}}


######################################################################
#   CLASS: RAFTNODE
#
#       ARGUMENTS
#
#           my_id                   - id of the ReplicaNode
#           other_node_ids          - array of the ids of all other nodes
#
#       ADDITIONAL STORED VARIABLES
#
#           my_state                - the state of the node
#           my_socket               - socket for messages to and from the node
#           raft_size               - number of nodes in the raft
#           quorum                  - number of nodes that constitutes a quorum
#           other_node_states_dict  - map of node ids to their index in the array of node states
#           other_node_states       - array that stores state information for each of the other nodes
#           getRequests             - array of all unresolved get requests
#           putRequests             - array of all unresolved put requests
#           requestLog              - log of all client requests
#           dictionary              - dictionary that stores all [key, value] pairs
#           node_type               - whether the node is a "follower", "candidate", or "leader
#           vote_tally              - how many votes the node has received in the current election (if any)
#           currentLeader           - id of the current leader
#           electionTimer           - timer for handling elections
#           electionTimeout         - election timeout value (random value between 150-300ms)
#           deltaElecTime           - how much time has passed since the last election timer reset
#           hbTimer                 - timer for handling heartbeats
#           heartbeatTimeout        - election timeout value (random value between 150-300ms)
#           deltaHbTime             - how much time has passed since the last election timer reset
#           messageCount            - how many messages the node has sent (for use in debugging)
#           printOwnMessages        - whether or not the node should print messages it sends to the console
#                                     (for use in debugging)
#           printClientMessages     - whether or not the node should print messages from clients to the console
#                                     (for use in debugging)
#           printClientResponses    - whether or not the node should print messages to clients to the console
#                                     (for use in debugging)
#           printElectionMessages   - whether or not the node should print election messages to the console
#                                     (for use in debugging)
#           printHeartbeatResponses - whether or not the node should print messages to clients to the console
#                                     (for use in debugging)
#           printCommits            - whether or not the node should print election messages to the console
#                                     (for use in debugging)
#           maxGetReqs              - maximum number of get requests that can be sent in a heartbeat
#
#       METHODS
#
#           resetElectionTimeout    - obtain a new election timeout value for the node (150-300ms) and reset the timer
#           checkElectionTimeout    - determine if the election timer has timed out
#           resetHbTimeout          - reset the node's heartbeat timer
#           checkHBTimeout          - determine if the heartbeat timer has timed out
#           requestVotes            - request votes from other nodes
#           isValidCandidate        - determine if a candidate's voteRequest is valid
#           castVote                - cast a vote for a given candidate
#           selfElect               - initiate a new election
#           handleVote              - logic for responding to a received vote
#           handleVoteRequest       - logic for responding to a received vote
#           becomeLeader            - upon receiving a quorum of votes, become the leader
#           handleGet               - logic for responding to a get request
#           confirmMessage          - respond to a client that their request was successfully made
#           handlePut               - logic for responding to a put request
#           failMessage             - respond to a client that their request failed or redirect them to the leader
#           validMessage            - does an incoming message contain the required fields
#           sendMessage             - JSON encode a given message and send it on the socket
#           handleHeartbeat         - logic for responding to a received heartbeat
#           failAllRequests         - fail all pending requests (used when a new leader is elected before the
#                                     requests are fulfilled)
#           heartbeat               - create and send a heartbeat message (only used by the leader)
#
class RaftNode:
    def __init__(self, my_id, other_node_ids):
        self.my_id = my_id
        self.my_state = ReplicaState("myState")
        self.my_socket = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
        self.my_socket.connect(self.my_id)
        self.raft_size = len(other_node_ids) + 1
        self.quorum = (self.raft_size / 2) + 1
        self.other_node_ids = []
        self.other_node_states_dict = dict()
        self.other_node_states = []
        for i in range(len(other_node_ids)):
            node_id = other_node_ids[i]
            self.other_node_ids.append(other_node_ids[i])
            state = ReplicaState(i)
            self.other_node_states.append(state)
            self.other_node_states_dict[node_id] = i
        self.getRequests = []
        self.putRequests = []
        self.requestLog = []
        self.dictionary = dict()
        self.node_type = "follower"
        self.vote_tally = 0
        self.currentLeader = "FFFF"
        self.currentTime = time.time()
        self.electionTimer = self.currentTime
        self.electionTimeout = 0.3
        self.deltaElecTime = 0
        self.resetElectionTimeout()
        self.hbTimer = self.currentTime
        self.heartbeatTimeout = 0.05
        self.deltaHbTime = 0
        self.messageCount = 0
        self.printOwnMessages = False
        self.printClientMessages = False
        self.printClientResponses = False
        self.printElectionMessages = False
        self.printNewLeader = False
        self.printHeartbeats = False
        self.printHeartbeatResponses = False
        self.printFailedHeartbeats = False
        self.printCommits = False
        self.maxGetReqs = 5
        self.maxOverrideEntries = 10
        self.isHealing = False
        self.isPartitioned = False
        self.lastCommitTimer = self.currentTime
        self.maxCommitTimer = 0.5
        self.timeoutCommits = False

    #############################
    ##                         ##
    ##     TIMEOUT HANDLING    ##
    ##                         ##
    #############################

    def setCurrentTime(self):
        self.currentTime = time.time()

    def resetElectionTimeout(self):
        # set the election timeout to a random number between 0.150 and 0.300
        self.electionTimeout = float(float(random.randrange(150, 300))/1000)
        self.electionTimer = self.currentTime
        self.deltaElecTime = 0

    def checkElectionTimeout(self):
        self.deltaElecTime = self.currentTime - self.electionTimer
        return self.deltaElecTime >= self.electionTimeout

    def resetHbTimeout(self):
        self.hbTimer = self.currentTime
        self.deltaHbTime = 0

    def checkHbTimeout(self):
        self.deltaHbTime = self.currentTime - self.hbTimer
        return self.deltaHbTime >= self.heartbeatTimeout

    def resetCommitTimer(self):
        self.lastCommitTimer = self.currentTime

    def lastCommitTimeout(self):
        if self.currentTime - self.lastCommitTimer >= self.maxCommitTimer:
            self.isPartitioned = True
            self.failAllRequests()
        else:
            self.isPartitioned = False

    ##############################
    ##                          ##
    ##     ELECTION HANDLING    ##
    ##                          ##
    ##############################

    def selfElect(self):
        self.node_type = "candidate"
        self.my_state.nextTerm()
        self.currentLeader = self.my_id
        # votes received
        self.vote_tally = 1
        if self.printElectionMessages:
            print "ELECTION{'term': " + str(self.my_state.term) + ", 'candidate': " + str(self.my_id) + ", 'time': " + str(self.currentTime) + "}"
        self.requestVotes()

    def requestVotes(self):
        for replica_id in self.other_node_ids:
            self.my_state.pPending = self.my_state.pCommitted
            # trim your log to only your committed log entries
            subArray = self.requestLog[:self.my_state.pCommitted]
            self.requestLog = subArray
            voteRequest = {'src': self.my_id, 'dst': replica_id, 'type': 'voteRequest', 'leader': self.currentLeader,
                           'state': self.my_state.getEntry(), 'candidate': self.my_id}
            self.sendMessage(voteRequest)
        self.my_state.votes = 0

    def castVote(self, candidate, dst):
        self.currentLeader = candidate
        self.node_type = "follower"
        vote = {'src': self.my_id, 'dst': dst, 'type': 'vote', 'leader': self.currentLeader, 'term': self.my_state.term,
                'candidate': candidate}
        if self.printElectionMessages:
            print str(vote)
        self.sendMessage(vote)
        self.my_state.votes = 0

    def isValidCandidate(self, state):
        return state['term'] >= self.my_state.term and \
               state['pCommitted'] >= self.my_state.pPending and \
               state['lastEntryTerm'] >= self.my_state.lastEntryTerm

    def handleVoteRequest(self, msg):
        state = msg['state']
        if self.isValidCandidate(state):
            candidate = msg['candidate']
            term = state['term']
            if term > self.my_state.term:
                self.my_state.toTerm(term)
                if self.node_type == "leader":
                    self.failAllRequests()
                self.my_state.pPending = self.my_state.pCommitted
                # trim your log to only your committed log entries
                subArray = self.requestLog[:self.my_state.pCommitted]
                self.requestLog = subArray
                self.castVote(candidate, candidate)
            elif term == self.my_state.term and self.my_state.votes > 0:
                self.castVote(candidate, candidate)

    def handleVote(self, msg):
        term = msg['term']
        candidate = msg['candidate']
        if self.node_type == "candidate":
            if term == self.my_state.term and candidate == self.my_id:
                self.vote_tally += 1
                if self.vote_tally >= self.quorum:
                    self.becomeLeader()

    def becomeLeader(self):
        if self.printElectionMessages:
            print "New leader: " + str(self.my_id) + ", Quorum: " + str(self.quorum) + \
                  ", State: " + str(self.my_state.getEntry())
        self.node_type = "leader"
        self.vote_tally = 0
        self.currentLeader = self.my_id
        self.getRequests = []
        self.putRequests = []
        self.resetCommitTimer()
        self.heartbeat()

    ##############################
    ##                          ##
    ##     GET/PUT REQUESTS     ##
    ##                          ##
    ##############################

    def validMessage(self, msg):
        return msg['src'] and msg['dst'] and msg['type'] and msg['leader']

    def handleGetProper(self, msg):
        if msg['key']:
            if self.node_type == "leader":
                request = GetRequest(msg, self.my_state.term, self.quorum)
                if msg['key'] in self.dictionary.keys():
                    request.setValue(self.dictionary.get(msg['key'])['value'])

                # if there is only one node in the raft
                if request.quorumMet:
                    self.confirmMessage(request, "get")
                else:
                    self.getRequests.append(request)
            else:
                self.failMessage(msg)
        else:
            self.failMessage(msg)

    def handleGetLazy(self, msg):
        if msg['key']:
            if self.node_type == "leader":
                request = GetRequest(msg, self.my_state.term, self.quorum)
                if msg['key'] in self.dictionary.keys():
                    request.setValue(self.dictionary.get(msg['key'])['value'])
                self.confirmMessage(request, "get")
            else:
                self.failMessage(msg)
        else:
            self.failMessage(msg)

    def handlePut(self, msg):
        # todo: check fail/ok conditions
        if msg['key'] and msg['value']:
            if self.node_type == "leader":
                request = PutRequest(msg, self.my_state.term, self.quorum)
                entry = request.getLogEntry()
                self.requestLog.append(entry)
                self.my_state.pPending += 1
                # if there is only one node in the raft
                if request.quorumMet:
                    self.dictionary[request.key] = {'value': request.value, 'term': self.my_state.term}
                    self.confirmMessage(request, "put")
                    self.my_state.pCommitted += 1
                else:
                    self.putRequests.append(request)
                    self.resetHbTimeout()
                    self.heartbeat()
            else:
                self.failMessage(msg)
        else:
            self.failMessage(msg)

    #############################
    ##                         ##
    ##     CLIENT RESPONSES    ##
    ##                         ##
    #############################

    def confirmMessage(self, request, reqType):
        response = {}
        if reqType == 'get':
            response = {'src': self.my_id, 'dst': request.source,
                        'leader': self.currentLeader, 'type': 'ok',
                        'MID': request.messageId, 'value': request.value}
        elif reqType == 'put':
            response = {'src': self.my_id, 'dst': request.source,
                        'leader': self.currentLeader, 'type': 'ok',
                        'MID': request.messageId}
        if len(response) > 0:
            if self.printClientResponses:
                print "################################"
                print "CONFIRMED: " + str(response) + "TIME: " + str(time.time()) + " MSG# " + str(self.messageCount)
                print "################################"
            self.sendMessage(response)

    def failMessage(self, msg):
        # todo: might have to change else case
        response = {}
        # fail message
        if self.my_id == self.currentLeader:
            response = {'src': self.my_id, 'dst': msg['src'],
                            'leader': self.currentLeader, 'type': 'fail',
                            'MID': msg['MID']}
        # redirect message
        elif msg['dst'] == self.my_id:
            response = {'src': self.my_id, 'dst': msg['src'],
                    'leader': self.currentLeader, 'type': 'redirect',
                    'MID': msg['MID']}
        if len(response) > 0:
            if self.printClientResponses:
                print "################################"
                print "FAILED: " + str(response) + "TIME: " + str(time.time()) + " MSG# " + str(self.messageCount)
                print "################################"
            self.sendMessage(response)

    def sendMessage(self, message):
        self.my_socket.send(json.dumps(message))
        self.messageCount += 1

    ########################
    ##                    ##
    ##     HEARTBEATS     ##
    ##                    ##
    ########################

    def handleHeartbeatLeader(self, msg):
        if msg['term'] and msg['appendEntries']:
            getResponse = {}
            message = {}
            if msg['term'] > self.my_state.term:
                self.my_state.toTerm(msg['term'])
                self.node_type = "follower"
                self.currentLeader = msg['leader']
                self.failHeartbeat()
                self.isPartitioned = False
                self.resetCommitTimer()
                self.failAllRequests()
            elif msg['term'] == self.my_state.term:
                # follower's pending pointer
                pPend = msg['appendEntries']['pPending']
                # follower's committed pointer
                pComm = msg['appendEntries']['pCommitted']
                # stored information about the follower's state
                node_state = self.other_node_states[self.other_node_states_dict.get(msg['src'])]
                # update node's state based on heartbeat
                node_state.pPending = pPend
                node_state.pCommitted = pComm
                # update any pending get requests
                self.updateGetRequests(msg['get'])
                if msg['appendEntries']['status'] == "ok":
                    # update node's state based on heartbeat
                    node_state.pPending = pPend
                    node_state.pCommitted = pComm
                    # if the node has the same pointers as you, it's status is valid
                    if pPend <= self.my_state.pPending and pComm <= self.my_state.pCommitted:
                        node_state.status = "ok"
                        if pPend > self.my_state.pCommitted:
                            for i in range(pPend - self.my_state.pCommitted):
                                key = self.requestLog[i + pComm]['key']
                                value = self.requestLog[i + pComm]['value']['value']
                                term = self.requestLog[i + pComm]['value']['term']
                                # find the pending put request
                                for req in self.putRequests:
                                    if req.key == key and req.value == value:
                                        # acknowledge the request
                                        req.ack(msg['src'])
                                        # if there is a quorum, respond to the client and update the dictionary
                                        if req.quorumMet and not req.confirmed:
                                            if self.printCommits:
                                                print "Committing entry: 'key: " + str(key) + ", 'value': " \
                                                      + str(value) + " TIME: " + str(time.time()) + " MSG# " \
                                                      + str(self.messageCount)
                                            self.dictionary[key] = {'value': value, 'term': self.my_state.term}
                                            self.resetCommitTimer()
                                            self.confirmMessage(req, 'put')
                                            req.confirmed = True
                                            self.my_state.pCommitted = pPend
                                        if req.num_acked_nodes == len(self.other_node_ids):
                                            self.putRequests.remove(req)
                                        break
                    else:
                        node_state.status = "fail"
                        self.isHealing = True
                elif msg['appendEntries']['status'] == "override":
                    # update node's state based on heartbeat
                    if pComm > node_state.pCommitted:
                        for i in range(pComm - self.my_state.pCommitted):
                            key = self.requestLog[i + self.my_state.pCommitted]['key']
                            value = self.requestLog[i + self.my_state.pCommitted]['value']['value']
                            term = self.requestLog[i + self.my_state.pCommitted]['value']['term']
                            # find the pending put request
                            for req in self.putRequests:
                                if req.key == key and req.value == value:
                                    # acknowledge the request
                                    req.ack(msg['src'])
                                    # if there is a quorum, respond to the client and update the dictionary
                                    if req.quorumMet and not req.confirmed:
                                        if self.printCommits:
                                            print "Committing entry: 'key: " + str(key) + ", 'value': " \
                                                  + str(value) + " TIME: " + str(time.time()) + " MSG# " \
                                                  + str(self.messageCount)
                                        self.dictionary[key] = {'value': value, 'term': self.my_state.term}
                                        self.resetCommitTimer()
                                        self.confirmMessage(req, 'put')
                                        req.confirmed = True
                                        self.my_state.pCommitted = pPend
                                    if req.num_acked_nodes == len(self.other_node_ids):
                                        self.putRequests.remove(req)
                                    break
                    node_state.pPending = pPend
                    node_state.pCommitted = pComm
                    self.isHealing = True
                    node_state.status = "fail"
                elif msg['appendEntries']['status'] == "fail":
                    self.isHealing = True
                    node_state.status = "fail"

    def updateGetRequests(self, getReqs):
        # if the node has responded to a get request
        if len(getReqs) > 0:
            getResponses = []
            for req in getReqs:
                messageId = req['MID']
                # if the node returned a value
                if len(req['value']) > 0:
                    val = req['value']
                    # find the corresponding get request
                    for num in range(len(self.getRequests)):
                        if self.getRequests[num].messageId == messageId:
                            # if the node agrees on the value
                            if self.getRequests[num].value == val:
                                self.getRequests[num].ack(msg['src'], True)
                            # if the node doesn't agree on the value
                            else:
                                self.getRequests[num].ack(msg['src'], False)
                            # if there is a quorum for the request and the request has not already been confirmed
                            if self.getRequests[num].quorumMet and not self.getRequests[num].confirmed:
                                self.confirmMessage(self.getRequests[num], 'get')
                                self.getRequests[num].confirmed = True
                            # if all nodes have responded to the request
                            if self.getRequests[num].num_acked_nodes == len(self.other_node_ids):
                                self.getRequests.remove(self.getRequests[num])
                            break

    def handleHeartbeatFollower(self, msg):
        # if it has the required fields
        if msg['term'] and msg['appendEntries']:
            getResponse = {}
            message = {}
            # if the leader's term is ahead of mine
            if msg['term'] > self.my_state.term:
                self.my_state.toTerm(msg['term'])
                self.node_type = "follower"
                self.currentLeader = msg['leader']
                self.isPartitioned = False
                self.resetCommitTimer()
                self.failHeartbeat()
            # if we are in the same term as the leader
            elif msg['term'] == self.my_state.term and msg['src'] == msg['leader']:
                if msg['leader'] != self.currentLeader:
                    self.currentLeader = msg['leader']
                    self.failHeartbeat()
                else:
                    # leader's pending pointer
                    pPend = msg['appendEntries']['pPending']
                    # leader's committed pointer
                    pComm = msg['appendEntries']['pCommitted']
                    # entries to append sent by the leader
                    msgEntries = msg['appendEntries']['entries']
                    # get answers to all of the get requests (if any)
                    getResps = self.followerGetResponse(msg['get'])
                    # if the leader thinks our state is okay
                    if len(msgEntries) > 0:
                        if msg['appendEntries']['status'] == "ok":
                            # if I have pending entries to commit, commit them to the dictionary
                            if self.my_state.pPending >= pComm and pComm > self.my_state.pCommitted:
                                for i in range(pComm - self.my_state.pCommitted):
                                    key = self.requestLog[i + self.my_state.pCommitted]['key']
                                    value = self.requestLog[i + self.my_state.pCommitted]['value']['value']
                                    term = self.requestLog[i + self.my_state.pCommitted]['value']['term']
                                    self.dictionary[key] = {'value': value, 'term': term}
                                self.my_state.pCommitted = pComm
                                # if there are any new pending entries, add them to the log
                                if pPend > self.my_state.pPending:
                                    for i in range(pPend - self.my_state.pPending):
                                        self.requestLog.append(msgEntries[i])
                                    self.my_state.pPending = pPend
                                # confirm the heartbeat
                                self.confirmHeartbeat(getResps)
                            # else if there are new pending entries but no new commits, add them to the log
                            elif pComm == self.my_state.pCommitted and pPend > self.my_state.pPending:
                                for i in range(pPend - self.my_state.pPending):
                                    self.requestLog.append(msgEntries[i])
                                self.my_state.pPending = pPend
                                # confirm the heartbeat
                                self.confirmHeartbeat(getResps)
                            # else fail
                            else:
                                self.failHeartbeat()
                        elif msg['appendEntries']['status'] == "override":
                            self.my_state.pPending = self.my_state.pCommitted
                            # trim your log to only your committed log entries
                            subArray = self.requestLog[:self.my_state.pCommitted]
                            self.requestLog = subArray
                            # add all of the given entries to your log
                            allPending = pPend - self.my_state.pCommitted > self.maxOverrideEntries
                            allCommits = pComm - self.my_state.pCommitted > self.maxOverrideEntries
                            numEntries = len(msgEntries)
                            overrideComm = self.my_state.pCommitted
                            overridePend = self.my_state.pPending
                            for entry in msgEntries:
                                self.requestLog.append(entry)
                            self.my_state.pPending += numEntries
                            allPending = self.my_state.pPending == pPend
                            # commit all entries that should be committed
                            if pComm > self.my_state.pCommitted:
                                if pComm - self.my_state.pCommitted <= self.maxOverrideEntries:
                                    allCommits = True
                                    numEntries = pComm - self.my_state.pCommitted
                                for i in range(numEntries):
                                    key = self.requestLog[i + self.my_state.pCommitted]['key']
                                    value = self.requestLog[i + self.my_state.pCommitted]['value']['value']
                                    term = self.requestLog[i + self.my_state.pCommitted]['value']['term']
                                    self.dictionary[key] = {'value': value, 'term': term}
                                self.my_state.pCommitted += numEntries
                            else:
                                allCommits = True
                            if self.my_state.pPending == pPend and self.my_state.pCommitted == pComm:
                                getResps = self.followerGetResponse(msg['get'])
                                self.confirmHeartbeat(getResps)
                            else:
                                self.overrideHeartbeat()
                    else:
                        if pPend == self.my_state.pPending and pComm >= self.my_state.pCommitted:
                            for i in range(pComm - self.my_state.pCommitted):
                                key = self.requestLog[i + self.my_state.pCommitted]['key']
                                value = self.requestLog[i + self.my_state.pCommitted]['value']['value']
                                term = self.requestLog[i + self.my_state.pCommitted]['value']['term']
                                self.dictionary[key] = {'value': value, 'term': term}
                            self.my_state.pCommitted = pComm
                            self.confirmHeartbeat(getResps)
                        elif pPend == self.my_state.pPending and pComm == self.my_state.pCommitted:
                            self.confirmHeartbeat(getResps)
                        else:
                            self.failHeartbeat()

    def followerGetResponse(self, getReqs):
        getResponses = []
        if len(getReqs) > 0:
            for req in getReqs:
                messageId = req['MID']
                key = req['key']
                if self.dictionary.has_key(key):
                    getResponse = {'MID': messageId, 'key': key, 'value': self.dictionary.get(key)['value']}
                    getResponses.append(getResponse)
                else:
                    getResponse = {'MID': messageId, 'key': key, 'value': {}}
                    getResponses.append(getResponse)
        return getResponses

    def confirmHeartbeat(self, getResps):
        message = {'src': self.my_id, 'dst': self.currentLeader, 'leader': self.currentLeader,
                   'term': self.my_state.term, 'type': 'heartbeat',
                   'appendEntries': {'status': 'ok', 'pPending': self.my_state.pPending,
                                     'pCommitted': self.my_state.pCommitted, "entries": {}}, 'get': getResps}
        if self.printHeartbeatResponses:
            print "HB RESPONSE " + str(message) + ", 'TIME': " + str(self.currentTime) + "}"
        self.sendMessage(message)

    def failHeartbeat(self):
        message = {'src': self.my_id, 'dst': self.currentLeader, 'leader': self.currentLeader,
                   'term': self.my_state.term, 'type': 'heartbeat',
                   'appendEntries': {'status': 'fail', 'pPending': self.my_state.pPending,
                                     'pCommitted': self.my_state.pCommitted, "entries": {}}, 'get': []}
        if self.printFailedHeartbeats:
            print "HB FAILED " + str(message) + ", 'TIME': " + str(self.currentTime) + "}"
        self.sendMessage(message)

    def overrideHeartbeat(self):
        message = {'src': self.my_id, 'dst': self.currentLeader, 'leader': self.currentLeader,
                   'term': self.my_state.term, 'type': 'heartbeat',
                   'appendEntries': {'status': 'override', 'pPending': self.my_state.pPending,
                                     'pCommitted': self.my_state.pCommitted, "entries": {}}, 'get': []}
        if self.printFailedHeartbeats:
            print "HB FAILED " + str(message) + ", 'TIME': " + str(self.currentTime) + "}"
        self.sendMessage(message)


    def handleHeartbeat(self, msg):
        if msg['term'] and msg['appendEntries']:
            getResponse = {}
            message = {}
            if msg['term'] > self.my_state.term:
                self.my_state.toTerm(msg['term'])
                self.node_type = "follower"
                self.currentLeader = str(msg['leader'])
                message = {'src': self.my_id, 'dst': msg['src'], 'leader': self.currentLeader,
                           'term': self.my_state.term, 'type': 'heartbeat',
                           'appendEntries': {'status': 'fail', 'pPending': self.my_state.pPending,
                                             'pCommitted': self.my_state.pCommitted, "entries": {}}}
                self.sendMessage(message)
                self.failAllRequests()
            elif msg['term'] == self.my_state.term:
                if self.node_type == "leader":
                    pPend = msg['appendEntries']['pPending']
                    pComm = msg['appendEntries']['pCommitted']
                    node_state = self.other_node_states[self.other_node_states_dict.get(msg['src'])]
                    node_state.pPending = pPend
                    node_state.pCommitted = pComm
                    if msg['appendEntries']['status'] == "ok":
                        node_state.status = "ok"
                        if pPend >= node_state.pPending and pComm == node_state.pCommitted:
                            if pPend - pComm > 0:
                                for i in range(pPend - pComm):
                                    key = self.requestLog[i + pComm]['key']
                                    value = self.requestLog[i + pComm]['value']['value']
                                    for req in self.putRequests:
                                        if req.key == key and req.value == value:
                                            req.ack(msg['src'])
                                            if req.quorumMet(self.quorum) and not req.confirmed:
                                                # print "Committing entry: 'key: " + str(key) + ", 'value': " + str(value) + " TIME: " + str(time.time()) + " MSG# " + str(self.messageCount)
                                                self.dictionary[key] = {'value': value, 'term': self.my_state.term}
                                                self.confirmMessage(req, 'put')
                                                req.confirmed = True
                                            if req.num_acked_nodes == len(self.other_node_ids):
                                                self.putRequests.remove(req)
                                            break
                                self.my_state.pCommitted = pPend
                    elif msg['appendEntries']['status'] == "fail":
                        node_state.status = "fail"
                    if len(msg['get']) > 0:
                        getResponses = []
                        getReqs = msg['get']
                        for req in getReqs:
                            # print str(msg)
                            messageId = req['MID']
                            # print req['value']['value']
                            if len(req['value']) > 0:
                                val = req['value']
                                # print val
                                for num in range(len(self.getRequests)):
                                    # print str(self.getRequests[num].value) + " == " + str(val)
                                    if self.getRequests[num].messageId == messageId and self.getRequests[num].value == val:
                                        #print str(self.getRequests[num].value) + " == " + str(val)
                                        self.getRequests[num].ack(msg['src'])
                                        if self.getRequests[num].quorumMet(self.quorum) and not self.getRequests[num].confirmed:
                                            self.confirmMessage(self.getRequests[num], 'get')
                                            self.getRequests[num].confirmed = True
                                        if self.getRequests[num].num_acked_nodes >= len(self.other_node_ids):
                                            self.getRequests.remove(self.getRequests[num])
                                        break
                elif self.node_type == "follower":
                    self.currentLeader = str(msg['leader'])
                    dest = str(msg['src'])
                    pPend = msg['appendEntries']['pPending']
                    pComm = msg['appendEntries']['pCommitted']
                    msgEntries = msg['appendEntries']['entries']
                    if msg['appendEntries']['status'] == "ok":
                        if self.my_state.pCommitted == pComm and self.my_state.pPending < pPend:
                            for i in range(pPend - self.my_state.pPending):
                                self.requestLog.append(msgEntries[i])
                            self.my_state.pPending = pPend
                            message = {'src': self.my_id, 'dst': dest, 'leader': self.currentLeader,
                                       'term': self.my_state.term, 'type': 'heartbeat',
                                       'appendEntries': {'status': 'ok', 'pPending': self.my_state.pPending,
                                                         'pCommitted': self.my_state.pCommitted, "entries": {}}, 'get': {}}
                        elif self.my_state.pPending <= pPend and self.my_state.pCommitted < pComm:
                            if self.my_state.pPending > pComm:
                                for i in range(pComm - self.my_state.pCommitted):
                                    key = self.requestLog[i + self.my_state.pCommitted]['key']
                                    value = self.requestLog[i + self.my_state.pCommitted]['value']['value']
                                    self.dictionary[key] = {'value': value, 'term': self.my_state.term}
                                self.my_state.pCommitted = pComm
                                message = {'src': self.my_id, 'dst': dest, 'leader': self.currentLeader,
                                           'term': self.my_state.term, 'type': 'heartbeat',
                                           'appendEntries': {'status': 'ok', 'pPending': self.my_state.pPending,
                                                             'pCommitted': self.my_state.pCommitted, "entries": {}}, 'get': {}}
                            else:
                                message = {'src': self.my_id, 'dst': dest, 'leader': self.currentLeader,
                                           'term': self.my_state.term, 'type': 'heartbeat',
                                           'appendEntries': {'status': 'fail', 'pPending': self.my_state.pPending,
                                                             'pCommitted': self.my_state.pCommitted, "entries": {}},
                                           'get': {}}
                        elif self.my_state.pCommitted == pComm and self.my_state.pPending == pPend:
                            message = {'src': self.my_id, 'dst': dest, 'leader': self.currentLeader,
                                       'term': self.my_state.term, 'type': 'heartbeat',
                                       'appendEntries': {'status': 'ok', 'pPending': self.my_state.pPending,
                                                         'pCommitted': self.my_state.pCommitted, "entries": {}},
                                       'get': {}}
                        else:
                            message = {'src': self.my_id, 'dst': dest, 'leader': self.currentLeader,
                                       'term': self.my_state.term, 'type': 'heartbeat',
                                       'appendEntries': {'status': 'fail', 'pPending': self.my_state.pPending,
                                                         'pCommitted': self.my_state.pCommitted, "entries": {}}, 'get': {}}
                    elif msg['appendEntries']['status'] == "override":
                        entrySubArray = self.requestLog[:pComm]
                        for i in range(pPend - self.my_state.pCommitted):
                            entrySubArray.append(msgEntries[i])
                        self.requestLog = entrySubArray
                        for i in range(pComm - self.my_state.pCommitted):
                            key = self.requestLog[i + self.my_state.pCommitted]['key']
                            value = self.requestLog[i + self.my_state.pCommitted]['value']['value']
                            self.dictionary[key] = {'value': value, 'term': self.my_state.term}
                        self.my_state.pPending = pPend
                        self.my_state.pCommitted = pComm
                        message = {'src': self.my_id, 'dst': dest, 'leader': self.currentLeader,
                                   'term': self.my_state.term, 'type': 'heartbeat',
                                   'appendEntries': {'status': 'ok', 'pPending': self.my_state.pPending,
                                                     'pCommitted': self.my_state.pCommitted, "entries": {}}, 'get': {}}
                    if len(msg['get']) > 0:
                        getResponses = []
                        getReqs = msg['get']
                        for req in getReqs:
                            messageId = req['MID']
                            key = req['key']
                            if self.dictionary.has_key(key):
                                getResponse = {'MID': messageId, 'key': key, 'value': self.dictionary.get(key)['value']}
                                getResponses.append(getResponse)
                            else:
                                getResponse = {'MID': messageId, 'key': key, 'value': {}}
                                getResponses.append(getResponse)
                            message['get'] = getResponses
                    self.sendMessage(message)

    def failAllRequests(self):
        for greq in self.getRequests:
            if not greq.confirmed:
                message = {'src': str(self.my_id), 'dst': str(greq.source),
                            'leader': str(self.currentLeader), 'type': 'redirect',
                            'MID': str(greq.messageId)}
                self.sendMessage(message)
        self.getRequests = []
        for preq in self.putRequests:
            if not preq.confirmed:
                message = {'src': str(self.my_id), 'dst': str(preq.source),
                           'leader': str(self.currentLeader), 'type': 'redirect',
                           'MID': str(preq.messageId)}
                self.sendMessage(message)
        self.putRequests = []

    def heartbeat(self):
        pPend = self.my_state.pPending
        pComm = self.my_state.pCommitted
        entries = []
        getRequest = None
        # if there are any pending get requests
        if len(self.getRequests) > 0:
            getRequest = []
            if len(self.getRequests) > self.maxGetReqs:
                i = 0
                while i <= self.maxGetReqs and i < len(self.getRequests):
                    if not self.getRequests[i].confirmed:
                        getRequest.append(self.getRequests[i].getEntry())
                    i += 1
            else:
                for req in self.getRequests:
                    if not req.confirmed:
                        getRequest.append(req.getEntry())
        message = {}
        hasPrinted = False
        self.isHealing = False
        failedNodes = self.failedNodes()
        okNodes = self.other_node_ids
        if len(failedNodes) > 0:
            self.isHealing = True
            for id in failedNodes:
                okNodes.remove(id)
                node_state = self.other_node_states[self.other_node_states_dict[id]]
                node_pPend = node_state.pPending
                node_pComm = node_state.pCommitted
                # get all log entries after the node's last committed request
                if pComm - node_pComm > self.maxOverrideEntries:
                    entries = self.requestLog[node_pComm:node_pComm + self.maxOverrideEntries]
                elif pComm - node_pComm > self.maxOverrideEntries:
                    entries = self.requestLog[node_pComm:node_pComm + self.maxOverrideEntries]
                else:
                    entries = self.requestLog[node_pComm:pPend]
                # if there are any pending get requests, add them to the heartbeat
                if getRequest is not None:
                    message = {"src": self.my_id, "dst": id, "leader": self.currentLeader, "type": "heartbeat",
                               "term": self.my_state.term,
                               "appendEntries": {"status": "override", "pPending": pPend, "pCommitted": pComm,
                                                 "entries": entries}, "get": getRequest}
                else:
                    message = {"src": self.my_id, "dst": id, "leader": self.currentLeader, "type": "heartbeat",
                               "term": self.my_state.term,
                               "appendEntries": {"status": "override", "pPending": pPend, "pCommitted": pComm,
                                                 "entries": entries}, 'get': []}
                if self.printHeartbeats and not hasPrinted:
                    print "HEARTBEAT " + str(message) + " TIME: " + str(self.currentTime)
                    hasPrinted = True
                self.sendMessage(message)
        for id in okNodes:
            node_state = self.other_node_states[self.other_node_states_dict[id]]
            node_pPend = node_state.pPending
            node_pComm = node_state.pCommitted
            if node_state.status == "ok":
                # if there are new pending entries, retrieve them from the log
                if pComm != pPend:
                    entries = self.requestLog[node_pComm:pPend]
                    """
                    if pComm - node_pComm > self.maxOverrideEntries:
                        entries = self.requestLog[node_pComm:node_pComm + self.maxOverrideEntries]
                    elif pComm - node_pComm > self.maxOverrideEntries:
                        entries = self.requestLog[node_pComm:node_pComm + self.maxOverrideEntries]
                    else:
                        entries = self.requestLog[node_pComm:pPend]
                        """
                # if there are any pending get requests, add them to the heartbeat
                if getRequest is not None:
                    message = {"src": self.my_id, "dst": id, "leader": self.currentLeader, "type": "heartbeat",
                               "term": self.my_state.term,
                               "appendEntries": {"status": "ok", "pPending": pPend, "pCommitted": pComm,
                                                 "entries": entries}, "get": getRequest}
                else:
                    message = {"src": self.my_id, "dst": id, "leader": self.currentLeader, "type": "heartbeat",
                               "term": self.my_state.term,
                               "appendEntries": {"status": "ok", "pPending": pPend, "pCommitted": pComm,
                                                 "entries": entries}, 'get': []}
            if self.printHeartbeats and not hasPrinted:
                print "HEARTBEAT " + str(message) + " TIME: " + str(self.currentTime)
                hasPrinted = True
            self.sendMessage(message)

    def failedNodes(self):
        failedNodes = []
        for id in self.other_node_ids:
            node_state = self.other_node_states[self.other_node_states_dict[id]]
            if node_state.status == "fail":
                failedNodes.append(id)
        return failedNodes

    def hasFailedNodes(self):
        failedNodes = False
        for id in self.other_node_ids:
            node_state = self.other_node_states[self.other_node_states_dict[id]]
            if node_state.status == "fail":
                failedNodes = True
                break
        return failedNodes


this_node = RaftNode(sys.argv[1], sys.argv[2:])

# print("Num Nodes: " + str(len(sys.argv[2:])))
# print("Quorum: " + str(this_node.quorum))

# Connect to the network. All messages to/from other replicas and clients will
# occur over this socket

while True:

    #ready = select.select([this_node.my_socket], [], [], this_node.electionTimeout)[0]

    # logic for checking for election timeouts
    this_node.setCurrentTime()

    hasFailedNodes = this_node.hasFailedNodes()
    if this_node.node_type == "leader" and this_node.hasFailedNodes():
        this_node.heartbeat()
        hasBeaten = True
    ready = select.select([this_node.my_socket], [], [], 0.03)[0]
    if this_node.my_socket in ready:
        msg_raw = this_node.my_socket.recv(32768)

        if len(msg_raw) > 0:
            if this_node.node_type != 'leader':
                this_node.resetElectionTimeout()
            msg = json.loads(msg_raw)
            if this_node.validMessage(msg):
                src = msg['src']
                type = str(msg['type'])
                if src not in this_node.other_node_ids:
                    this_node.messageCount += 1
                    if this_node.printClientMessages:
                        print "********************************"
                        print str(msg) + " TIME: " + str(time.time()) + " MSG# " + str(this_node.messageCount)
                        print "********************************"
                    if type == 'get':
                        this_node.handleGetLazy(msg)
                    if type == 'put':
                        this_node.handlePut(msg)

                # Handle election voting
                else:
                    if type == 'vote':
                        this_node.handleVote(msg)
                    elif type == 'voteRequest':
                        this_node.handleVoteRequest(msg)
                    elif type == 'heartbeat':
                        if this_node.node_type == "leader":
                            this_node.handleHeartbeatLeader(msg)
                        elif this_node.node_type == "follower":
                            this_node.handleHeartbeatFollower(msg)
            else:
                this_node.failMessage(msg)

    # if the election timer has timed out, initiate a new election
    if this_node.checkElectionTimeout() and this_node.node_type != "leader":
        this_node.resetElectionTimeout()
        this_node.selfElect()
    # if the heartbeat timer has timed out,
    elif this_node.checkHbTimeout() and this_node.node_type == "leader":
        this_node.resetHbTimeout()
        this_node.heartbeat()

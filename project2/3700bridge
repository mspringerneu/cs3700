#!/usr/bin/python -u
import sys
import socket
import select
import json
import time

BPDU_TIMEOUT = .75
BPDU_BROADCAST = .5
FWDTBL_TIMEOUT = 5.0

######################################################################
# All print statements
class PrintStatements:

    ######################################################################
    #BPDU Messages

    #Print Bridge starting
    def print_bridge_start(self, id):
        print "Bridge " + str(id) + " starting up\n"

    #Print statement for when bridge changes root
    def print_new_root(self, id, root):
        print "New root: " + str(id) + " / " + str(root) + "\n"

    #Print new root port
    def print_new_root_port(self, id, portID):
        print "Root port: " + str(id) + " / " + str(portID) + "\n"

    #Print Designated port
    def print_designated_port(self, id, portID):
        print "Designated port: " + str(id) + " / " + str(portID) + "\n"

    #Print disabled port
    def print_disabled_port(self, id, portID):
        print "Disabled port: " + str(id) + " / " + str(portID) + "\n"


    ######################################################################
    #Data Messages

    #Printing received messages
    def print_received_message(self, id, portID, source, dest):
        print "Received message " + str(id) + " on port " + str(portID) + " from " + str(source) + " to " + str(dest) + "\n"


    #Printing forwarding message
    def print_forwarding_message(self, id, portID):
        print "Forwarding message " + str(id) + " on port " + str(portID) + "\n"

    #Printing broadcasting message
    def print_broadcasting_message(self, id, ports):
        print "Broadcasting message " + str(id) + " on ports: " + str(ports) + "\n"

    #Printing forwarding message
    def print_not_forwarding_message(self, id):
        print "Not forwarding message " + str(id) + "\n"


######################################################################






######################################################################
'''
CLASS BRIDGE

id    = bridgesID (supplied by config)

ports = - created during initialization
        - includes socket
'''


class Bridge:
    def __init__(self, id):
        self.id = id
        # stores the best BPDU received across all port
        self.BPDU = Bpdu(id, id, 0)
        self.bestBPDU = Bpdu(id, id, 0)
        self.ports = []
        self.forwardingTable = []
        # index of the root port in self.ports
        self.rootPort = None
        self.isRoot = True

    # todo: add forwarding table timeout method, add port bpdu array timeout method
    def update(self):
        #self.updateBPDUs()
        self.timeoutForwardingTable()

    def updateMyBPDU(self):
        self.BPDU.root = self.bestBPDU.root
        self.BPDU.cost = self.bestBPDU.cost + 1
        self.broadcastBPDU()


    # searches for the best BPDU across all ports and stores it in self.bpdu
    def updateBPDUs(self):
        rootIndex = self.rootPort
        newBestBPDU = False
        for x in self.ports:
            if self.updatePortBPDU(x):
                newBestBPDU = True
                rootIndex = x.id
        if newBestBPDU:
            if rootIndex != self.rootPort:
                self.makeRoot(rootIndex)
                self.updateMyBPDU()
                self.flushForwardingTable()
                for x in self.ports:
                    if not x.isRoot:
                        x.setPortStatus(self)
            else:
                self.updateMyBPDU()
                for x in self.ports:
                    if not x.isRoot:
                        x.setPortStatus(self)
        else:
            for x in self.ports:
                if not x.isRoot:
                    x.setPortStatus(self)

    # done after a new BPDU is added- sees if that BPDU's port has any new information	
    # return true if the port's best BPDU is better than the bridge's current best BPDU
    # if port BPDU is better, store it as the bridge's best BPDU
    def updatePortBPDU(self, x):
        if len(x.BPDUs) > 0:
            # if port root <= bridge best bpdu root
            if self.bestBPDU.root >= x.BPDUs[0].root:
                # if port root < best bpdu root
                if self.bestBPDU.root > x.BPDUs[0].root:
                    # sets this bridges BPDU to x's 0 indexed bpdu
                    self.bestBPDU = x.BPDUs[0]
                    # mutate x's 0 index bpdu to reflect that
                    return True
                # if port root == bridge best bpdu root && port cost <= bridge best bpdu cost
                elif self.bestBPDU.cost >= x.BPDUs[0].cost:
                    # if port cost < bridge best bpdu cost
                    if self.bestBPDU.cost > x.BPDUs[0].cost:
                        self.bestBPDU = x.BPDUs[0]
                        return True
                    # if port cost == bridge best bpdu cost
                    else:
                        # if port source < bridge best bpdu source
                        if self.bestBPDU.source > x.BPDUs[0].source:
                            self.bestBPDU = x.BPDUs[0]
                            return True
                        # if port source >= bridge best bpdu source
                        else:
                            return False
                # bridge BPDU has same root but lower lost than port's best BPDU
                else:
                    return False
            # bridge BPDU has a lower root than port's best BPDU
            else:
                return False
        # port has no BPDUs
        else:
            return False

    # returns the index of the port containing a specific socket
    def getSocketPortIndex(self, sock):
        for i in range(len(self.ports)):
            if self.ports[i].socket == sock:
                return i
                break


    # SETTING ALL INFORMATION for the root port
    def makeRoot(self, portIndex):
        # set all the ports to not being the root port
        for x in self.ports:
            x.isRoot = False
        self.rootPort = portIndex
        self.ports[portIndex].isRoot = True
        self.ports[portIndex].isEnabled(True)
        self.ports[portIndex].designatedPort = False
        PrintStatements().print_new_root_port(self.id, self.rootPort)

    def removeDuplicateFwdTableEntry(self, address):
        for x in self.forwardingTable:
            if x.address == address:
                self.forwardingTable.remove(x)


    def addForwardingTableEntry(self, address, portIndex):
        self.removeDuplicateFwdTableEntry(address)
        self.forwardingTable.append(ForwardingTableEntry(address, portIndex))

    def getForwardingPort(self,address):
        inTable = False
        for x in self.forwardingTable:
            if x.address == address:
                inTable = True
                if self.ports[x.port].activePort:
                    return x.port
                else:
                    return -1
        if not inTable:
            return -1


    def timeoutForwardingTable(self):
        timer = time.time()
        for x in self.forwardingTable:
            if timer - x.time > FWDTBL_TIMEOUT:
                self.forwardingTable.remove(x)

    def flushForwardingTable(self):
        self.forwardingTable = []

    def timeoutBPDUs(self):
        for i in range(len(self.ports)):
            if self.ports[i].timeoutBPDUs(self.id):
                self.flushForwardingTable()

    def broadcastBPDU(self):
        bpduMessage = {"source":self.BPDU.source,"dest":"ffff","type":"bpdu","message":{"id":self.BPDU.source,"root":self.BPDU.root,"cost":self.BPDU.cost}}
        for x in self.ports:
            x.socket.send(json.dumps(bpduMessage))

    def broadcast(self, dataMessage, receivingPort):
        ports = []
        for x in self.ports:
            if (x.activePort) and x.id != receivingPort:
                ports.append(x.id)
                x.socket.send(json.dumps(dataMessage))
        return ports




######################################################################






######################################################################
'''
CLASS PORT

id                   = (0 indexed port)

socket               = socket associated with this port

BPDUS                = BPDU's that were received on this port

designatedPort       = Is this port a designatedPort

'''


class Port:
    def __init__(self, id, socket):
        self.id = id
        self.socket = socket
        self.BPDU = None
        self.BPDUs = []
        # status codes:
        # 0 - root
        # 1 - designated
        # 2 - disabled
        self.status = 1
        self.isRoot = False
        self.activePort = True
        self.designatedPort = True

    def isEnabled(self, enabled):
        self.activePort = enabled

    def isDesignated(self, designated):
        self.designatedPort = designated


    def evaluateBPDUs(self, bpdu):
        insertedBPDU = True
        if len(self.BPDUs) == 0:
            self.BPDUs.append(bpdu)
            return True
        else:
            if self.sameSourceBPDU(bpdu):
                if self.handleSameSourceBPDU(bpdu):
                    return False
                else:
                    for i in range(len(self.BPDUs)):
                        if self.evaluateBPDU(i, bpdu):
                            self.BPDUs.insert(i, bpdu)
                            if i == 0:
                                return True
                            else:
                                insertedBPDU = True
                                break
                    if not insertedBPDU:
                        self.BPDUs.append(bpdu)
                        return False
                    else:
                        return False
            else:
                for i in range(len(self.BPDUs)):
                    if self.evaluateBPDU(i, bpdu):
                        self.BPDUs.insert(i, bpdu)
                        if i == 0:
                            return True
                        else:
                            insertedBPDU = True
                            break
                if not insertedBPDU:
                    self.BPDUs.append(bpdu)
                    return False
                else:
                    return False


    # determines whether or not a port should store a new BPDU
    # if it decides to store the BPDU, it places it at the front of the list
    def evaluateBPDU(self, index, bpdu):
        if self.BPDUs[index].root >= bpdu.root:

            if self.BPDUs[index].root > bpdu.root:
                return True
            elif self.BPDUs[index].cost >= bpdu.cost:
                if self.BPDUs[index].cost > bpdu.cost:
                    return True
                elif self.BPDUs[index].source >= bpdu.source:
                    return True
                else: return False
            else: return False
        else: return False

    def timeoutBPDUs(self, bridgeId):
        timer = time.time()
        for x in self.BPDUs:
            if timer - x.time > BPDU_TIMEOUT:
                self.BPDUs.remove(x)
        if len(self.BPDUs) == 0:
            if not self.activePort and self.designatedPort:
                self.activePort = True
                self.designatedPort = True
                PrintStatements().print_designated_port(bridgeId, self.id)
                return True
            else:
                return False
        else:
            return False

    def setPortStatus(self, bridge):
        # 0 root
        # 1 active & designated
        # 2 disabled
        status = -1
        if len(self.BPDUs) == 0:
            if not self.activePort and self.designatedPort:
                self.activePort = True
                self.designatedPort = True
                bridge.flushForwardingTable()
                PrintStatements().print_designated_port(bridge.BPDU.source, self.id)
        else:
            active = False
            designated = False
            for x in self.BPDUs:
                if x.root == bridge.BPDU.root:
                    if x.cost >= bridge.BPDU.cost:
                        if x.cost == bridge.BPDU.cost:
                            if x.source < bridge.BPDU.source:
                                active = False
                                designated = False
                                break
                            else:
                                active = True
                                designated = True
                        else:
                            active = True
                            designated = True
                    else:
                        if not self.isRoot:
                            active = False
                            designated = False
                            break
                else:
                    active = True
                    designated = False

            if self.activePort:
                if not active:
                    self.activePort = active
                    PrintStatements().print_disabled_port(bridge.BPDU.source, self.id)
                    bridge.flushForwardingTable()
            else:
                if active:
                    self.activePort = active
                    bridge.flushForwardingTable()
            if self.designatedPort:
                if not designated:
                    self.designatedPort = designated
                    bridge.flushForwardingTable()
            else:
                if designated:
                    self.designatedPort = designated
                    PrintStatements().print_designated_port(bridge.BPDU.source, self.id)
                    bridge.flushForwardingTable()


    def activePortss(self, x, y):
        # active when len(self.BPDUs) == 0
        # active when self.isRoot
        # active when any item in self.BPDUs has same root && cost == bridge cost + 1 || same root && cost == bridge cost && bridge id < source id
        returnValue = False
        if self.BPDUs[0].root != x:
            self.activePort = False
        returnValue = True
        return returnValue

    def designatedPortss(self, x, y):
        returnValue = False
        if len(self.BPDUs) > 0:
            if self.BPDUs[0].root ==  x:
                self.designatedPort = True
                returnValue = False
        return returnValue

    def sameSourceBPDU(self, bpdu):
        sameBPDU = False
        for i in range(len(self.BPDUs)):
            if bpdu.source == self.BPDUs[i].source:
                sameBPDU = True
        return sameBPDU


    def handleSameSourceBPDU(self, bpdu):
        sameBPDU = False
        for i in range(len(self.BPDUs)):
            if bpdu.source == self.BPDUs[i].source:
                if bpdu.root == self.BPDUs[i].root and bpdu.cost == self.BPDUs[i].cost:
                    self.BPDUs[i].time = bpdu.time
                    sameBPDU = True
                    break
                else:
                    self.BPDUs.remove(self.BPDUs[i])
                    sameBPDU = False
                    break
        return sameBPDU



######################################################################






######################################################################


class Bpdu:
    def __init__(self, source, root, cost):
        self.source = source
        self.root = root
        self.cost = cost
        self.time = time.time()


######################################################################
'''
CLASS BRIDGE

address    = source of the received message

port       = port the message was received on

time       = time the entry was created
'''


class ForwardingTableEntry:
    def __init__(self, address, portIndex):
        self.address = address
        self.port = portIndex
        self.time = time.time()

######################################################################


######################################################################
'''
CLASS HELPER: for helper methods

- pad (pads data for transfer



'''


class Helper:
    def pad(self, name):
        result = '\0' + name
        while len(result) < 108:
            result += '\0'
        return result



######################################################################
def main():

    # bridge id as indicated by the command arg
    id = sys.argv[1]
    # remove potential duplicate LAN arguments
    LAN = []
    for x in sys.argv[2:]:
        if x not in LAN:
            LAN.append(x)
    print LAN
    sockets = []

    # instantiate the bridge
    bridge = Bridge(id)

    # bridge clock
    bpduTimer = time.time()
    fwdTableTimer = time.time()
    broadcastTimer = 0

    # creates sockets and connects to them
    for x in range(len(LAN)):
        s = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
        s.connect(Helper().pad(LAN[x]))
        sockets.append(s)
        # setting up initial bridge and port information
        port = Port(x, s)
        # increase the count
        # add the port to this bridges ports
        bridge.ports.append(port)
        ############################################
        # at this point this bridge and its associated ports are configured

    # Print that the bridge is starting
    PrintStatements().print_bridge_start(bridge.id)

    bridge.broadcastBPDU()

    # Main loop
    while True:
        timer = time.time()
        deltaBpduTime = timer - bpduTimer
        deltaBroadcastTime = timer - broadcastTimer
        deltaFwdTime = timer - fwdTableTimer

        if deltaBroadcastTime > BPDU_BROADCAST:
            bridge.broadcastBPDU()
            broadcastTimer = timer
        if deltaBpduTime > BPDU_TIMEOUT:
            bridge.timeoutBPDUs()
            bpduTimer = timer

        if deltaFwdTime > FWDTBL_TIMEOUT:
            bridge.timeoutForwardingTable()
            fwdTableTimer = timer

        # point of control for rest of main()
        # refresh spanning tree based on current BPDUs

        # Calls select with all the sockets; change the timeout value (1)
        ready, ignore, ignore2 = select.select(sockets, [], [], .1)

        # Reads from each of the ready sockets
        for x in range(len(ready)):
            # int index of the port storing the socket
            socketPort = bridge.getSocketPortIndex(ready[x])
            # socket receiving the message
            currentSocket = bridge.ports[socketPort].socket
            # read JSON message
            data = json.loads(currentSocket.recv(1500))


            ###########################################################################

            # if the received message is a BPDU:
            if data['type'] == "bpdu":
                # create a BPDU object from the JSON
                newBPDU = Bpdu(data['source'], data['message']['root'], data['message']['cost'])
                # if never seen source before: look at it
                # if have seen source: pair it and compare it
                # designated / active
                # broadcast on change

                # stores the new BPDU in the port's array of BPDUs, returns True if the new
                # BPDU is the best for that port
                if bridge.ports[socketPort].evaluateBPDUs(newBPDU):
                    bridge.updateBPDUs()
                #
                # if(bridge.ports[socketPort].activePortss(bridge.bpdu.root, bridge.bpdu.cost)):
                #     bridge.flushForwardingTable()
                #
                # if(bridge.ports[socketPort].designatedPortss(bridge.bpdu.root, bridge.bpdu.cost)):
                #     bridge.flushForwardingTable()

                ###########################################################################


            elif data['type'] == "data":
                #todo: store addresses from disabled ports in forwarding table, forward mesages to root
                if bridge.ports[socketPort].activePort:
                    PrintStatements().print_received_message(data['message']['id'], socketPort, data['source'], data['dest'])


                    ###########################################################################



                    # logic abstraction
                    #   if source in fwd table -> reset entry timer
                    #   else -> add new entry for source
                    #   if dest in fwd table -> send message on corresponding port
                    #   else -> broadcast on all ports except current port

                    bridge.addForwardingTableEntry(data['source'], socketPort)
                    fwdPort = bridge.getForwardingPort(data['dest'])
                    if fwdPort == -1:
                        ports = bridge.broadcast(data, socketPort)
                        PrintStatements().print_broadcasting_message(data['message']['id'], ports)
                    else:
                        # the last and in this i am not sure about
                        if fwdPort != socketPort:
                            bridge.ports[fwdPort].socket.send(json.dumps(data))
                            PrintStatements().print_forwarding_message(data['message']['id'], fwdPort)
                        else:
                            PrintStatements().print_not_forwarding_message(data['message']['id'])
                else:
                    PrintStatements().print_received_message(data['message']['id'], socketPort, data['source'],
                                                             data['dest'])
                    PrintStatements().print_not_forwarding_message(data['message']['id'])

        #bridge.update()

######################################################################


main()



#!/usr/bin/python -u

import sys
import socket
import select
import json
import time

BPDU_TIMEOUT = .75
BPDU_BROADCAST = .5
FWDTBL_TIMEOUT = 5.0

######################################################################
# All print statements
class PrintStatements:

    ######################################################################
    #BPDU Messages

    #Print Bridge starting
    def print_bridge_start(self, id):
        print "Bridge " + str(id) + " starting up\n"

    #Print statement for when bridge changes root
    def print_new_root(self, id, root):
        print "New root: " + str(id) + " / " + str(root) + "\n"

    #Print new root port
    def print_new_root_port(self, id, portID):
        print "Root port: " + str(id) + " / " + str(portID) + "\n"

    #Print Designated port
    def print_designated_port(self, id, portID):
        print "Designated port: " + str(id) + " / " + str(portID) + "\n"

    #Print disabled port
    def print_disabled_port(self, id, portID):
        print "Disabled port: " + str(id) + " / " + str(portID) + "\n"


    ######################################################################
    #Data Messages

    #Printing received messages
    def print_received_message(self, id, portID, source, dest):
        print "Received message " + str(id) + " on port " + str(portID) + " from " + str(source) + " to " + str(dest) + "\n"


    #Printing forwarding message
    def print_forwarding_message(self, id, portID):
        print "Forwarding message " + str(id) + " on port " + str(portID) + "\n"

    #Printing broadcasting message
    def print_broadcasting_message(self, id, ports):
        print "Broadcasting message " + str(id) + " on all ports: {" + str(ports) + "}\n"

    #Printing forwarding message
    def print_not_forwarding_message(self, id):
        print "Not forwarding message " + str(id) + "\n"


######################################################################






######################################################################
'''
CLASS BRIDGE

id    = bridgesID (supplied by config)

ports = - created during initialization
        - includes socket
'''


class Bridge:
    def __init__(self, id):
        self.id = id
        # stores the best BPDU received across all port
        self.bpdu = Bpdu(id, id, 0)
        self.ports = []
        self.forwardingTable = []
        # index of the root port in self.ports
        self.rootPort = None

    # todo: add forwarding table timeout method, add port bpdu array timeout method
    def update(self):
        self.timeoutForwardingTable()
        self.updateBPDUs()


    # searches for the best BPDU across all ports and stores it in self.bpdu
    def updateBPDUs(self):
        for x in self.ports:
            self.updatePortBPDU(x)

    # todo: logic for disabling ports
    # checks a port's best (0-indexed) BPDU and compares it to the bridge's best BPDU
    # if the BPDU is better than the currently stored best BPDU, the bridge updates
    def updatePortBPDU(self, x):
        if len(x.BPDUs) > 0:
            index = x.id
            if self.bpdu.root >= x.BPDUs[0].root:
                if self.bpdu.root > x.BPDUs[0].root:
                    self.bpdu = x.BPDUs[0]
                    self.makeRoot(index)
                    self.flushForwardingTable()
                elif self.bpdu.cost >= x.BPDUs[0].cost:
                    if self.bpdu.cost > x.BPDUs[0].cost:
                        self.bpdu = x.BPDUs[0]
                        self.makeRoot(index)
                        self.flushForwardingTable()
                    else:
                        if self.bpdu.source > x.BPDUs[0].source:
                            self.bpdu = x.BPDUs[0]
                            self.disablePort(self.rootPort)
                            self.makeRoot(index)
                            self.flushForwardingTable()
                        elif self.bpdu.source < x.BPDUs[0].source:
                            self.disablePort(index)
                            self.flushForwardingTable()

    # returns the index of the port containing a specific socket
    def getSocketPortIndex(self, sock):
        for i in range(len(self.ports)):
            if self.ports[i].socket == sock:
                print "This socket's port index is: " + str(i)
                return i
                break

    def makeRoot(self, portIndex):
        for x in self.ports:
            x.isRoot = False
        self.rootPort = portIndex
        self.ports[portIndex].isRoot = True
        self.ports[portIndex].isEnabled(True)
        PrintStatements().print_new_root_port(self.id, self.rootPort)

    def disablePort(self, portIndex):
        self.ports[portIndex].isEnabled(False)
        PrintStatements().print_disabled_port(self.id, portIndex)

    def addForwardingTableEntry(self, address, portIndex):
        newEntry = True
        for i in range(len(self.forwardingTable)):
            if self.forwardingTable[i].address == address:
                self.forwardingTable[i].port = portIndex
                self.forwardingTable[i].time = time.time()
                newEntry = False
                return self.forwardingTable[i].port
        if newEntry:
            self.forwardingTable.append(ForwardingTableEntry(address, portIndex))

    def getForwardingPort(self,address):
        inTable = False
        for x in self.forwardingTable:
            if x.address == address:
                inTable = True
                if self.ports[x.port].activePort:
                    return x.port
                else: return -1
        if not inTable:
            return -1


    def timeoutForwardingTable(self):
        timer = time.time()
        for x in self.forwardingTable:
            if timer - x.time > FWDTBL_TIMEOUT:
                self.forwardingTable.remove(x)

    def flushForwardingTable(self):
        self.forwardingTable = []

    def timeoutBPDUs(self):
        for i in range(len(self.ports)):
            self.ports[i].timeoutBPDUs(self.id)

    def broadcastBPDU(self):
        bpdu = self.bpdu
        bpdu.id = self.id
        bpdu.cost += 1
        bpduMessage = {"source":self.id,"dest":"ffff","type":"bpdu","message":{"id":self.id,"root":bpdu.root,"cost":bpdu.cost}}
        for x in self.ports:
            if x.activePort:
                x.socket.send(json.dumps(bpduMessage))

    def broadcast(self, dataMessage, receivingPort):
        ports = []
        for x in self.ports:
            if x.activePort and x.id != receivingPort:
                ports.append(x.id)
                x.socket.send(json.dumps(dataMessage))
        return ports

######################################################################






######################################################################
'''
CLASS PORT

id                   = (0 indexed port)

socket               = socket associated with this port

BPDUS                = BPDU's that were received on this port

designatedPort       = Is this port a designatedPort

'''


class Port:
    def __init__(self, id, socket):
        self.id = id
        self.socket = socket
        self.BPDUs = []
        self.isRoot = False
        self.activePort = True
        self.designatedPort = False

    def isEnabled(self, enabled):
        self.activePort = enabled

    def isDesignated(self, designated):
        self.designatedPort = designated

    def evaluateBPDUs(self, bpdu):
        for i in range(len(self.BPDUs)):
            if self.evaluateBPDU(i, bpdu):
                self.insert(i, bpdu)
                break


    # determines whether or not a port should store a new BPDU
    # if it decides to store the BPDU, it places it at the front of the list
    def evaluateBPDU(self, index, bpdu):
        if self.BPDUs[index].root >= bpdu.root:
            if self.BPDUs[index].root > bpdu.root:
                return True
            elif self.BPDUs[index].cost >= bpdu.cost:
                if self.BPDUs[index].cost > bpdu.cost:
                    return True
                elif self.BPDUs[index].source >= bpdu.source:
                    return True
                else: return False
            else: return False
        else: return False

    def timeoutBPDUs(self, bridgeId):
        timer = time.time()
        for i in range(len(self.BPDUs)):
            if timer - self.BPDUs[i].time > BPDU_TIMEOUT:
                self.BPDUS.pop(i)
        if len(self.BPDUs) == 0:
            self.isDesignated(True)
            PrintStatements().print_designated_port(bridgeId, self.id)

######################################################################






######################################################################
'''
CLASS BPDU

source - the bridges id where it came from

dest- the destination for the BPDU ('ffff' for all)

type- the type of message (obviously 'bpdu')

cost- the cost to the root id

time- time BPDU was created- used to figure out when it should be killed by reciever

'''


class Bpdu:
    def __init__(self, source, root, cost):
        self.source = source
        self.root = root
        self.cost = cost
        self.time = time.time()


######################################################################
'''
CLASS BRIDGE

address    = source of the received message

port       = port the message was received on

time       = time the entry was created
'''


class ForwardingTableEntry:
    def __init__(self, address, portIndex):
        self.address = address
        self.port = portIndex
        self.time = time.time()

######################################################################


######################################################################
'''
CLASS HELPER: for helper methods

- pad (pads data for transfer



'''


class Helper:
    def pad(self, name):
        result = '\0' + name
        while len(result) < 108:
            result += '\0'
        return result



######################################################################
def main():

    # used to index ports on this
    count = 0
    # bridge id as indicated by the command arg
    id = sys.argv[1]
    # remove potential duplicate LAN arguments
    LAN = []
    for x in sys.argv[2:]:
        if x not in LAN:
            LAN.append(x)
    print LAN
    sockets = []

    # instantiate the bridge
    bridge = Bridge(id)

    # bridge clock
    bpduTimer = time.time()
    broadcastTimer = time.time()

    # creates sockets and connects to them
    for x in range(len(LAN)):
        s = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
        s.connect(Helper().pad(LAN[x]))
        sockets.append(s)
        # setting up initial bridge and port information
        port = Port(x, s)
        # increase the count
        count += 1
        # add the port to this bridges ports
        bridge.ports.append(port)
        ############################################
        # at this point this bridge and its associated ports are configured

    # Print that the bridge is starting
    PrintStatements().print_bridge_start(bridge.id)

    # Main loop
    while True:
        timer = time.time()
        deltaBpduTime = bpduTimer - timer
        deltaBroadcastTime = broadcastTimer - timer

        if deltaBroadcastTime > BPDU_BROADCAST:
            bridge.broadcastBPDU()
            broadcastTimer = timer
        if deltaBpduTime > BPDU_TIMEOUT:
            bridge.timeoutBPDUs()
            bpduTimer = timer

        # point of control for rest of main()
        # refresh spanning tree based on current BPDUs
        bridge.update()

        # Calls select with all the sockets; change the timeout value (1)
        ready, ignore, ignore2 = select.select(sockets, [], [], 1)

        # Reads from each of the ready sockets
        for x in range(len(ready)):
            socketPort = bridge.getSocketPortIndex(ready[x])
            currentSocket = bridge.ports[socketPort].socket
            data = json.loads(currentSocket.recv(1500))
            if data['type'] == "bpdu":
                newbpdu = Bpdu(data['source'], data['message']['root'], data['message']['cost'])
                if bridge.ports[socketPort].evaluateBPDUs(newbpdu):
                    bridge.updatePortBPDU(bridge.ports[socketPort])
            elif data['type'] == "data":
                PrintStatements().print_received_message(data['message']['id'], socketPort, data['source'], data['dest'])
                # logic abstraction
                #   if source in fwd table -> reset entry timer
                #   else -> add new entry for source
                #   if dest in fwd table -> send message on corresponding port
                #   else -> broadcast on all ports except current port
                bridge.addForwardingTableEntry(data['source'], socketPort)
                fwdPort = bridge.getForwardingPort(data['dest'])
                if fwdPort == -1:
                    ports = bridge.broadcast(data, socketPort)
                    PrintStatements().print_broadcasting_message(data['message']['id'], ports)
                else:
                    if fwdPort != socketPort:
                        bridge.ports[fwdPort].socket.send(json.dumps(data))
                        PrintStatements().print_forwarding_message(data['message']['id'], fwdPort)

######################################################################

main()

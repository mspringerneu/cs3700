HIGH LEVEL APPROACH

We decided to again use Python for our project, as we were both familiar with it after using it on Project 1, and we both enjoyed using it.

At a high level, we decided to create a 'Bridge' object, a 'Port' object, a 'BPDU' object, and a 'ForwardingTableEntry' object.  A Bridge stores an array of Ports, its own BPDU, the best BPDU stored across all ports, and an array of ForwardingTableEntries, comprising the forwarding table.  A port stores an array of BPDUs and a socket.

Whenever a message is received, we check if the message is a BPDU or a Data message.  If it's a BPDU, we check it against the BPDUs currently stored in that Port.  If it's new and better than all other BPDUs for that port, we check it against the best BPDUs for all other ports to determine if we need to set a new root, otherwise, if it's new but not better, we adjust the port's status if need be.  If it's not new, we simply reset the timer for that BPDU entry so that it doesn't get timed out.  If the message is a Data message, we check the forwarding table for an entry for the sender.  If there is already an entry, we update the port with the current receiving port and reset the timeout timer.  If there isn't, we create a new ForwardingTableEntry with the sender's address, the current receiving port, and the current time.time().  Then, we check if the destination address is in the Bridge's ForwardingTable.  If it is, and that port is not the current receiving port, we forward the message on that port.  Otherwise, we forward the message on all active ports except the current receiving port.

CHALLENGES FACED

One of the major challenges we faced was getting the simple-6.conf and advanced-2.conf configurations to pass the ./test.  These were extremely frustrating, as they were difficult to trace, but by stepping through the ./run executions and using the testing methods outlined below, as well as making efficient use of office hours, we were able to figure out what we were missing and fix our program accordingly.

For the simple-6.conf configuration, we ultimately realized that, after establishing a port as a root port, we were accidentally undoing that when we called our 'setPortStatus()' method across all ports, which activates or deactivates ports.  By omitting the root port from this function call, we solved that problem.

The advanced-2.conf configuration was even more frustrating, as we were consistently passing all other tests except for this one.  Ultimately, after stepping through the printouts with corresponding diagrams, we discovered that the error was with the way that we were timing out BPDUs.  We attempted to alter our 'timeoutBPDUs()' method, but it gave inconsistent results when executed in the ./test script.  Ultimately, after speaking with the professor, we realized that we were overthinking the issue, and that we should flush all BPDUs when one of them times out.  When we implemented this, the program finally worked properly.

TESTING STRATEGY

We made extensive use of the ./test program for testing during the later stages of development, where we were trying to gauge performance and single out the specific scenarios where our bridges were not functioning as intended.  Once we isolated the specific config files that we were consistently failing, we focused on each one specifically.  Often, when we fixed one issue, many of the other conifgurations would also be fixed.

To focus on a specific config file, we would use ./run to try and execute the program, and pipe the printouts into a .txt file.  We would also use the Dia Diagram Editor to draw the bridged network at each point in time during the execution of that specific instance (if a bridge gets added at t=5, we would have a diagram for t=0;t<5, and another for t>=5;t<lifetime).  Using these diagrams and the printout in the .txt file, we could step through the process and ensure that the bridge ports were operating properly by tracing the paths of the messages.  On the more advanced configurations, there were often too many messages to step through efficiently, so we concentrated on the periods immediately after a bridge is added/deleted to ensure the spanning tree is rebuilt properly and that messages are sent properly afterwards.  If we encounter a situation where the bridge and its ports are not operating as they should, we highlighted those printouts and tried to determine what was causing that behavior, and then altered our code accordingly.
